[{"content":"Twitch4J Client Helper The Twitch4J Client Helper aims to bundle some common code used by library users to prevent everyone from reinventing the wheel ;)\nCurrent Features:\nEvent: StreamGoLiveEvent / StreamGoOffflineEvent / StreamChangeGameEvent / StreamChangeTitleEvent Event: FollowEvent Those methods require the Helix Module, so enable it in the TwitchClientBuilder.\nDefault Credential When using the client helper, you will need to specify a default credential (any) that gets used for all requests for increased ratelimits, this is mandatory!\nTwitchClient twitchClient = TwitchClientBuilder.builder() .withDefaultAuthToken(new OAuth2Credential(\u0026#34;twitch\u0026#34;, \u0026#34;oauthtokenhere\u0026#34;)) .build(); def twitchClient = TwitchClientBuilder.builder() .withDefaultAuthToken(new OAuth2Credential(\u0026#34;twitch\u0026#34;, \u0026#34;oauthtokenhere\u0026#34;)) .build(); val twitchClient = TwitchClientBuilder.builder() .withDefaultAuthToken(OAuth2Credential(\u0026#34;twitch\u0026#34;, \u0026#34;oauthtokenhere\u0026#34;)) .build(); Register for Stream GoLive / GoOffline / GameChange / TitleChange Events twitchClient.getClientHelper().enableStreamEventListener(\u0026#34;twitch4j\u0026#34;); twitchClient.clientHelper.enableStreamEventListener(\u0026#34;twitch4j\u0026#34;); twitchClient.clientHelper.enableStreamEventListener(\u0026#34;twitch4j\u0026#34;); Register for Follow Event twitchClient.getClientHelper().enableFollowEventListener(\u0026#34;twitch4j\u0026#34;); twitchClient.clientHelper.enableFollowEventListener(\u0026#34;twitch4j\u0026#34;); twitchClient.clientHelper.enableFollowEventListener(\u0026#34;twitch4j\u0026#34;); ","tags":null,"title":"Client Helper","url":"/docs/twitch4j/client-helper/"},{"content":"Twitch4J Welcome and thanks for using Twitch4J!\nPlease check out the Installation page to install the Twitch4J dependency.\nAfter that the Client-Builder will show you how to create a Twitch4J Instance.\nNow you\u0026rsquo;r ready to check out a few example projects:\nTwitch4J Chatbot Events Many modules can generate events which you can handle in some way, like PubSub, Chat, \u0026hellip;\nFor a list of available events / information on how to listen to events please check out: Events\nResults of API Calls This API Client provides you 3 methods to handle / process the results of api calls.\nSynchronous Execution You can execute any api call synchronously with the execute() method, as shown in the following example:\nUserList users = twitchClient.getHelix().getUsers(null, null, Arrays.asList(\u0026#34;twitch4j\u0026#34;)).execute(); UserList users = twitchClient.helix.getUsers(null, null, [\u0026#34;twitch4j\u0026#34;]).execute(); var userList: users = twitchClient.helix.getUsers(null, null, arrayOf(\u0026#34;twitch4j\u0026#34;)).execute(); Asynchronous Execution You can execute any api call asynchronously with the queue() method, as shown in the following example:\nFuture\u0026lt;UserList\u0026gt; users = twitchClient.getHelix().getUsers(null, null, Arrays.asList(\u0026#34;twitch4j\u0026#34;)).queue(); Future\u0026lt;UserList\u0026gt; users = twitchClient.helix.getUsers(null, null, [\u0026#34;twitch4j\u0026#34;]).queue() var users: Future\u0026lt;UserList\u0026gt; = twitchClient.helix.getUsers(null, null, arrayOf(\u0026#34;twitch4j\u0026#34;)).queue() You can retrieve the result of the async method at any time by calling .get() on the future, for example: users.get().\nFor more information on how you can work with Future please check out this guide: https://www.baeldung.com/java-future\nReactive Execution You can also observe the results of any api call as an Observable by using one of the following methods:\nobserve() — returns a “hot” Observable that executes the command immediately, though because the Observable is filtered through a ReplaySubject you are not in danger of losing any items that it emits before you have a chance to subscribe toObservable() — returns a “cold” Observable that won’t execute the command and begin emitting its results until you subscribe to the Observable Observable\u0026lt;UserList\u0026gt; users = twitchClient.getKraken().getUsers(null, null, Arrays.asList(\u0026#34;twitch4j\u0026#34;)).observe(); Observable\u0026lt;UserList\u0026gt; users = twitchClient.kraken.getUsers(null, null, [\u0026#34;twitch4j\u0026#34;]).observe() var users: Observable\u0026lt;UserList\u0026gt; = twitchClient.kraken.getUsers(null, null, arrayOf(\u0026#34;twitch4j\u0026#34;)) .observe() You then retrieve the value of the command by subscribing to the Observable:\nusers.subscribe(data -\u0026gt; { // your code to work with the result data }); users.subscribe { data -\u0026gt; // your code to work with the result data } users.subscribe { data -\u0026gt; // your code to work with the result data } Contribute to this documentation Feel free to update this content, just press this button below to edit it as usual markdown files and send a pull request.\n","tags":null,"title":"Getting started","url":"/docs/getting-started/"},{"content":"Leave Channel Description Leaves a channel, will not receive any futher events (Messages, Subscriptions, Bits, \u0026hellip;)\nExample twitchClient.getChat().leaveChannel(\u0026#34;PlayOverwatch\u0026#34;); twitchClient.chat.leaveChannel(\u0026#34;PlayOverwatch\u0026#34;) twitchClient.chat.leaveChannel(\u0026#34;PlayOverwatch\u0026#34;) ","tags":null,"title":"Leave Channel","url":"/docs/chat/leave-channel/"},{"content":"Twitch4J The Twitch4J Client Package includes the builder from the getting started section. Please visit those pages if you want to start using Twitch4J.\nFurthermore it includes some common code snippets, for example to get followers or to track the go live events of a stream. Please check out the TwitchClientHelper for such examples.\n","tags":null,"title":"Twitch4J","url":"/docs/twitch4j/"},{"content":"Installation We recommend using a dependency management tool to manage twitch4j and sub dependencies. As a fallback method you can also download a fatJar adding shaded scope to your configuration build. dependencies { implementation group: \u0026#39;com.github.twitch4j\u0026#39;, name: \u0026#39;twitch4j\u0026#39;, version: \u0026#39;1.11.0\u0026#39; // or using it into compile api group: \u0026#39;com.github.twitch4j\u0026#39;, name: \u0026#39;twitch4j\u0026#39;, version: \u0026#39;1.11.0\u0026#39; } dependencies { implementation(group = \u0026#34;com.github.twitch4j\u0026#34;, name = \u0026#34;twitch4j\u0026#34;, version = \u0026#34;1.11.0\u0026#34;) // or using it into compile api(group = \u0026#34;com.github.twitch4j\u0026#34;, name = \u0026#34;twitch4j\u0026#34;, version = \u0026#34;1.11.0\u0026#34;) } \u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.twitch4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;twitch4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.11.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; ","tags":null,"title":"Installation","url":"/docs/getting-started/installation/"},{"content":"Send Channel Message Description Sends a message to a twitch channel.\nThe messages will go into a queue internally so we won\u0026rsquo;t hit the rate-limit. This could cause some minor deleays when sending a lot of messages. The queue will only be processed when we\u0026rsquo;re connected to twitch. Example twitchClient.getChat().sendMessage(\u0026#34;twitch4j\u0026#34;, \u0026#34;Hey!\u0026#34;); twitchClient.chat.sendMessage(\u0026#34;twitch4j\u0026#34;, \u0026#34;Hey!\u0026#34;) twitchClient.chat.sendMessage(\u0026#34;twitch4j\u0026#34;, \u0026#34;Hey!\u0026#34;) ","tags":null,"title":"Send Channel Message","url":"/docs/chat/send-message/"},{"content":"Send Private Message Description Sends a private message to a user.\nThe messages will go into a queue internally so we won\u0026rsquo;t hit the rate-limit. This could cause some minor deleays when sending a lot of messages. The queue will only be processed when we\u0026rsquo;re connected to twitch. Example twitchClient.getChat().sendPrivateMessage(\u0026#34;twitch4j\u0026#34;, \u0026#34;Hey! This is a direct message.\u0026#34;); twitchClient.chat.sendPrivateMessage(\u0026#34;twitch4j\u0026#34;, \u0026#34;Hey! This is a direct message.\u0026#34;) twitchClient.chat.sendPrivateMessage(\u0026#34;twitch4j\u0026#34;, \u0026#34;Hey! This is a direct message.\u0026#34;) ","tags":null,"title":"Send Private Message","url":"/docs/chat/send-private-message/"},{"content":"Twitch Chat (WebSocket) Twitch offers an IRC interface to our chat functionality. This allows you to, for instance:\nDevelop bots for your channel. Connect to a channel’s chat with an IRC client instead of using the Web interface. While our IRC server generally follows RFC1459, there are several cases where it behaves slightly differently than other IRC servers; as described below, there are many Twitch-specific IRC capabilities. The differences are necessary to accommodate:\nThe massive scale at which our chat servers operate, and Complex Twitch-specific features that we provide (to viewers, broadcasters, and developers). Rate-Limiting\nThe library follows the official rate-limits and has a queue for a maximum of 200 messages. After that old messages will be removed from the queue in favor of more recent messages. Methods JoinChannel LeaveChannel SendMessage SendPrivateMessage Handle ChannelMessage Handle PrivateMessage Use as part of Twitch4J To use Twitch Chat and events from chat, you need to specify withEnableChat when building the Twitch4J Instance, as shown below: // chat credential OAuth2Credential credential = new OAuth2Credential(\u0026#34;twitch\u0026#34;, \u0026#34;oAuthTokenHere\u0026#34;); // twitch client TwitchClient twitchClient = TwitchClientBuilder.builder() ... .withEnableChat(true) .withChatAccount(oAuth2CredentialHere) ... .build(); // chat credential def credential = new OAuth2Credential(\u0026#34;twitch\u0026#34;, \u0026#34;oAuthTokenHere\u0026#34;) // twitch client def twitchClient = TwitchClientBuilder.builder() ... .withEnableChat(true) .withChatAccount(oAuth2CredentialHere) ... .build() // chat credential val credential = OAuth2Credential(\u0026#34;twitch\u0026#34;, \u0026#34;oAuthTokenHere\u0026#34;) // twitch client val twitchClient = TwitchClientBuilder.builder().apply { ... withEnableChat(true) withChatAccount(oAuth2CredentialHere) ... }.build() A OAuth2Credential is a generic oauth credentials so the first parameter is always twitch. The 2nd value is your oauth token, you can generate a chat-bot token here.\nWhen you build a TwitchClient Twitch4J will automatically connect you to chat (via WebSocket). So you can start joining channels and listening to messages after this - refer to the methods documented above.\nUse Standalone Initialize the Chat Feature as Standalone Module, also requires setting up the EventManager and the CredentialManger yourself:\n// credential manager CredentialManager credentialManager = CredentialManagerBuilder.builder().build(); credentialManager.registerIdentityProvider(new TwitchIdentityProvider(\u0026#34;jzkbprff40iqj646a697cyrvl0zt2m6\u0026#34;, \u0026#34;**SECRET**\u0026#34;, \u0026#34;\u0026#34;)); // twitch4j - chat TwitchChat client = TwitchChatBuilder.builder() .withCredentialManager(credentialManager) .withChatAccount(oAuth2CredentialHere) .build(); // credential manager def credentialManager = CredentialManagerBuilder.builder().build() credentialManager.registerIdentityProvider(new TwitchIdentityProvider(\u0026#34;jzkbprff40iqj646a697cyrvl0zt2m6\u0026#34;, \u0026#34;**SECRET**\u0026#34;, \u0026#34;\u0026#34;)) // twitch4j - chat def client = TwitchChatBuilder.builder() .withCredentialManager(credentialManager) .withChatAccount(oAuth2CredentialHere) .build() // credential manager val credentialManager = CredentialManagerBuilder.builder().build().also { it.registerIdentityProvider(TwitchIdentityProvider(\u0026#34;jzkbprff40iqj646a697cyrvl0zt2m6\u0026#34;, \u0026#34;**SECRET**\u0026#34;, \u0026#34;\u0026#34;)) } // twitch4j - chat val client = TwitchChatBuilder.builder().apply { withCredentialManager(credentialManager) withChatAccount(oAuth2CredentialHere) }.build() The UserId is required, since it will be used to get the oauth credentials\n","tags":null,"title":"Chat","url":"/docs/chat/"},{"content":"Twitch API - Helix To make an application that uses the Twitch API, you first need to register your application on the Twitch developer site. When creating this app, enter your redirect URI, which is where your users are redirected after being authorized.\nOnce you create a developer application, you are assigned a client ID. Some authentication flows also require a client secret, which you can generate on the same page as the client ID.\nClient IDs are public and can be shared (for example, embedded in the source of a Web page). Client secrets are equivalent to a password for your application and must be kept confidential. Never expose it to users, even in an obscured form. Because your client secret is confidential, we cannot show it to you once you leave the page, so make sure to record it somewhere safe. Also, generating a new client secret immediately invalidates the current one, which might make your API requests fail until your app is updated.\nWarning: Client IDs should be unique for each application: do not re-use client IDs across multiple applications. Also, applications should request the appropriate set of scopes for the intended target APIs. Failure to adhere to these guidelines may result in the suspension of your application’s access to the Twitch API.\nYou can create new application on the Twitch Developer Console\nAs Module: Twitch4J To use Helix you need to enable the Helix API when building the Twitch4J Instance, as shown below:\nTwitchClient twitchClient = TwitchClientBuilder.builder() ... .withEnableHelix(true) ... .build(); def twitchClient = TwitchClientBuilder.builder() ... .withEnableHelix(true) ... .build() val twitchClient = TwitchClientBuilder.builder() ... .withEnableHelix(true) ... .build() Standalone Initialize the Helix API as Standalone Module:\nTwitchHelix client = TwitchHelixBuilder.builder() .withClientId(\u0026#34;clientId\u0026#34;) .withClientSecret(\u0026#34;clientSecret\u0026#34;) .build(); def client = TwitchHelixBuilder.builder() .withClientId(\u0026#34;clientId\u0026#34;) .withClientSecret(\u0026#34;clientSecret\u0026#34;) .build() val client = TwitchHelixBuilder.builder() .withClientId(\u0026#34;clientId\u0026#34;) .withClientSecret(\u0026#34;clientSecret\u0026#34;) .build() API Methods Analytics:\nAnalytics -\u0026gt; Extension Analytics Url Analytics -\u0026gt; Game Analytics Url Bits:\nBits -\u0026gt; Get Leaderboard Bits -\u0026gt; Get Cheermotes Clips:\nClips -\u0026gt; Create Clip Clips -\u0026gt; Get Clips Entitlements:\nCreate Entitlement Grants Upload URL Entitlements -\u0026gt; Get Code Status Entitlements -\u0026gt; Redeem Code Games:\nGames -\u0026gt; Search Games -\u0026gt; Top Games Moderation:\nModerators -\u0026gt; Get Moderators -\u0026gt; Get Events Streams:\nStreams -\u0026gt; Search Streams -\u0026gt; Get Key Create Stream Marker Streams -\u0026gt; Get Markers Subscriptions:\nSubscriptions -\u0026gt; Get All Subscriptions -\u0026gt; Get by UserId Users:\nUsers -\u0026gt; Get Users -\u0026gt; Get Followers Users -\u0026gt; Update Users -\u0026gt; Get Extensions Users -\u0026gt; Get Active Extensions Update User Extensions Videos:\nVideos -\u0026gt; Search Get Webhook Subscriptions ","tags":null,"title":"API - Helix","url":"/docs/rest-helix/"},{"content":"Twitch4J Client Builder All Features Initialize the Twitch4J Client and specify which modules you want to use:\nTwitchClient twitchClient = TwitchClientBuilder.builder() .withEnableHelix(true) .build(); def twitchClient = TwitchClientBuilder.builder() .withEnableHelix(true) .build() val twitchClient = TwitchClientBuilder.builder() .withEnableHelix(true) .build() Logging Please check out Logging on how to set up logging.\n","tags":null,"title":"Client-Builder","url":"/docs/getting-started/client-builder/"},{"content":"Development Environment We are using Project Lombok to generate some parts of the java code, so you will have to setup the lombok plugin in your ide to compile / run Twitch4J.\nProject Lombok This repository uses lombok to avoid the Getter/Setter boilerplate code in many classes. Therefore you need to install Lombok for you IDE:\nIntelliJ - Plugin Installation In 2020.3+ Lombok plugin has been embeded to IDE. There is no need to installing proper version. But in older version is required if you wanna contribute to our repository.\nUsing IDE built-in plugin system on Windows: File \u0026gt; Settings \u0026gt; Plugins \u0026gt; Browse repositories... \u0026gt; Search for \u0026#34;lombok\u0026#34; \u0026gt; Install Plugin Using IDE built-in plugin system on MacOs: Preferences \u0026gt; Settings \u0026gt; Plugins \u0026gt; Browse repositories... \u0026gt; Search for \u0026#34;lombok\u0026#34; \u0026gt; Install Plugin Manually: Download the latest release and install it manually using Preferences \u0026gt; Plugins \u0026gt; Install plugin from disk... Restart IDE.\nEclipse - Plugin Installation Download the latest lombok.jar from the official Website.\nJust run lombok.jar which will open the setup dialog, you need to specify your eclipse installation path here.\nJavadoc Generation To generate the Javadocs in HTML5 you should use JDK9 or newer - the option will be set automatically based on your java version.\n","tags":null,"title":"IDE - Development Environment","url":"/docs/contribution/ide/"},{"content":"Pull Request Please create your pull requests against the develop branch.\nPlease use this pull request template when creating a pull request.\n","tags":null,"title":"Pull Request","url":"/docs/contribution/pull-request/"},{"content":"Twitch API - Kraken (Deprecated, removal not scheduled) To make an application that uses the Twitch API, you first need to register your application on the Twitch developer site. When creating this app, enter your redirect URI, which is where your users are redirected after being authorized.\nOnce you create a developer application, you are assigned a client ID. Some authentication flows also require a client secret, which you can generate on the same page as the client ID.\nClient IDs are public and can be shared (for example, embedded in the source of a Web page). Client secrets are equivalent to a password for your application and must be kept confidential. Never expose it to users, even in an obscured form. Because your client secret is confidential, we cannot show it to you once you leave the page, so make sure to record it somewhere safe. Also, generating a new client secret immediately invalidates the current one, which might make your API requests fail until your app is updated.\nWarning: Client IDs should be unique for each application: do not re-use client IDs across multiple applications. Also, applications should request the appropriate set of scopes for the intended target APIs. Failure to adhere to these guidelines may result in the suspension of your application’s access to the Twitch API.\nYou can register a new application on the Twitch Developer Console\nAs Module: Twitch4J To use Kraken you need to enable the Kraken API when building the full Twitch4J Client Instance, as shown below:\nTwitchClient twitchClient = TwitchClientBuilder.builder() ... .withEnableKraken(true) ... .build(); def twitchClient = TwitchClientBuilder.builder() ... .withEnableKraken(true) ... .build(); val twitchClient = TwitchClientBuilder.builder() ... .withEnableKraken(true) ... .build(); Standalone If you just want to use the Kraken API by itself, as Standalone Module:\nTwitchKraken client = TwitchKrakenBuilder.builder() .withClientId(\u0026#34;clientId\u0026#34;) .withClientSecret(\u0026#34;clientSecret\u0026#34;) .build(); def client = TwitchKrakenBuilder.builder() .withClientId(\u0026#34;clientId\u0026#34;) .withClientSecret(\u0026#34;clientSecret\u0026#34;) .build(); val client = TwitchKrakenBuilder.builder() .withClientId(\u0026#34;clientId\u0026#34;) .withClientSecret(\u0026#34;clientSecret\u0026#34;) .build(); API Methods All methods that were added to the Helix API (aka the \u0026ldquo;New Twitch API\u0026rdquo;) have been removed from this Kraken module, so please use those instead. Twitch documentation for this API can be found on the Twitch Developers web site for the API v5.\nChannelFeed:\nOpen for Contributions Chat:\nOpen for Contributions Collections:\nOpen for Contributions Channel\nChannel - Get Subscriptions Users:\nUser -\u0026gt; Get User -\u0026gt; Add Follow Ingests:\nIngests -\u0026gt; Get All Teams:\nTeams -\u0026gt; Get All Teams -\u0026gt; Get by Name ","tags":null,"title":"API - Kraken","url":"/docs/rest-kraken/"},{"content":"Get Extension Analytics Gets a URL that extension developers can use to download analytics reports (CSV files) for their extensions. The URL is valid for 5 minutes. For details about analytics and the fields returned, see the Insights \u0026amp; Analytics guide.\nMethod Definition @RequestLine(\u0026#34;GET /analytics/extensions?after={after}\u0026amp;ended_at={ended_at}\u0026amp;first={first}\u0026amp;extension_id={extension_id}\u0026amp;started_at={started_at}\u0026amp;type={type}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;ExtensionAnalyticsList\u0026gt; getExtensionAnalyticUrl( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;after\u0026#34;) String after, @Param(\u0026#34;first\u0026#34;) Integer limit, @Param(\u0026#34;extension_id\u0026#34;) String extensionId, @Param(\u0026#34;type\u0026#34;) String type, @Param(\u0026#34;started_at\u0026#34;) String startedAt, @Param(\u0026#34;ended_at\u0026#34;) String endedAt ); Required Parameters\nName Type Description authToken string User Auth Token Optional Parameters\nName Type Description after string Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. This applies only to queries without extension_id. If an extension_id is specified, it supersedes any cursor/offset combinations. The cursor value specified here is from the pagination response field of a prior query. first string Maximum number of objects to return. Maximum: 100. Default: 20. type string Type of analytics report that is returned. If this is specified, the response includes one URL, for the specified report type. If this is not specified, the response includes multiple URLs (paginated), one for each report type available for the authenticated user’s Extensions. Limit: 1. Valid values: \u0026ldquo;overview_v1\u0026rdquo;, \u0026ldquo;overview_v2\u0026rdquo;. Default: all report types for the authenticated user’s Extensions. extension_id string Client ID value assigned to the extension when it is created. If this is specified, the returned URL points to an analytics report for just the specified extension. If this is not specified, the response includes multiple URLs (paginated), pointing to separate analytics reports for each of the authenticated user’s extensions. started_at string Starting date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z. This must be on or after January 31, 2018.If this is provided, ended_at also must be specified. If started_at is earlier than the default start date, the default date is used. Default: January 31, 2018 (overview_v2) or 90 days (overview_v1) before the report was issued. The file contains one row of data per day. ended_at string Ending date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z. The report covers the entire ending date; e.g., if 2018-05-01T00:00:00Z is specified, the report covers up to 2018-05-01T23:59:59Z. If this is provided, started_at also must be specified. If ended_at is later than the default end date, the default date is used. Default: 1-2 days before the request was issued (depending on report availability). Code-Snippets print report url (to download the files) ExtensionAnalyticsList resultList = twitchClient.getHelix().getExtensionAnalyticUrl(accessToken, null, 10, null, null, null, null).execute(); resultList.getExtensionAnalytics().forEach(analytic -\u0026gt; { System.out.println(\u0026#34;URL: \u0026#34; + analytic.getURL()); }); def resultList = twitchClient.helix.getExtensionAnalyticUrl(accessToken, null, 10, null, null, null, null).execute(); resultList.extensionAnalytics.each { analytic -\u0026gt; System.out.println \u0026#34;URL: ${analytic.uRL}\u0026#34; } val resultList = twitchClient.helix.getExtensionAnalyticUrl(accessToken, null, 10, null, null, null, null).execute(); resultList.extensionAnalytics.forEach { analytic -\u0026gt; println(\u0026#34;URL: ${analytic.uRL}\u0026#34;); } ","tags":null,"title":"Analytics - Extensions","url":"/docs/rest-helix/analytics-extension-url/"},{"content":"Twitch API - Messaging Interface The Twitch Chat System has a few unofficial endpoints which get exposed from https://tmi.twitch.tv.\nAs Module: Twitch4J To use TMI you need to enable the TMI API when building the Twitch4J Instance, as shown below:\nTwitchClient twitchClient = TwitchClientBuilder.builder() ... .withEnableTMI(true) ... .build(); def twitchClient = TwitchClientBuilder.builder() ... .withEnableTMI(true) ... .build() val twitchClient = TwitchClientBuilder.builder() ... .withEnableTMI(true) ... .build() Standalone Initialize the Helix API as Standalone Module:\nTwitchHelix client = TwitchMessagingInterfaceBuilder.builder() .withClientId(\u0026#34;clientId\u0026#34;) .withClientSecret(\u0026#34;clientSecret\u0026#34;) .build(); def client = TwitchMessagingInterfaceBuilder.builder() .withClientId(\u0026#34;clientId\u0026#34;) .withClientSecret(\u0026#34;clientSecret\u0026#34;) .build() val client = TwitchMessagingInterfaceBuilder.builder() .withClientId(\u0026#34;clientId\u0026#34;) .withClientSecret(\u0026#34;clientSecret\u0026#34;) .build() API Methods TMI -\u0026gt; Get Viewers ","tags":null,"title":"API - TMI","url":"/docs/rest-tmi/"},{"content":"Twitch4J - CredentialManager If you use any module that reqires auth directly, you need to setup your credentialManager and pass it into the builder on the .withCredentialManager(credentialManager) method.\nRegister the twitch identity provider using the AuthModule Register the twitch identity provider manually CredentialManager credentialManager = CredentialManagerBuilder.builder().build(); credentialManager.registerIdentityProvider(new TwitchIdentityProvider(\u0026#34;jzkbprff40iqj646a697cyrvl0zt2m6\u0026#34;, \u0026#34;**SECRET**\u0026#34;, \u0026#34;\u0026#34;)); def credentialManager = CredentialManagerBuilder.builder().build() credentialManager.registerIdentityProvider(new TwitchIdentityProvider(\u0026#34;jzkbprff40iqj646a697cyrvl0zt2m6\u0026#34;, \u0026#34;**SECRET**\u0026#34;, \u0026#34;\u0026#34;)) val credentialManager = CredentialManagerBuilder.builder().build().also { it.registerIdentityProvider(TwitchIdentityProvider(\u0026#34;jzkbprff40iqj646a697cyrvl0zt2m6\u0026#34;, \u0026#34;**SECRET**\u0026#34;, \u0026#34;\u0026#34;)) } ","tags":null,"title":"CredentialManager","url":"/docs/credentialmanager/"},{"content":"Releases The release process is fully automated using GitLab CI and gets triggered by git tag creation. There are no further actions required.\nRelease Notes The releasenotes are generated using EnvCLI/Modular-Pipeline.\nDiscord Announcements The project contains a CI Variable called RELEASE_WEBHOOK_DISCORD which points to a discord webhook on the twitch4j announcements channel.\nGitHub Releases The project contains a GH_TOKEN thats used to create new GitHub Releases using the API, using the same changelog information as discord but with a different markup template.\nConventions To generate a human readable changelog, the commits have to follow the following naming convention:\nCommit Message Changelog Category feature: Features feat: Features fix: Bug Fixes bugfix: Bug Fixes perf: Performance Improvements refactor: Code Refactoring chore: Internal docs: Documentation ","tags":null,"title":"Releases","url":"/docs/contribution/release/"},{"content":"Support We are officiallly support on this discord server, but we are not officially be a part of Twitch: Alternative Discord Server for all available libraries: ","tags":null,"title":"Support","url":"/docs/getting-started/support/"},{"content":"Get Chatters Description Gets vip\u0026rsquo;s, moderators, staff, admins and normal viewers that are currently present in the chat. (Viewers that use a embedded viewer without chat can\u0026rsquo;t be tracked using this)\nThere is no other way to request information about current viewers, as such this is currently the only way to get a list of people watching a stream.\nMethod Definition @RequestLine(\u0026#34;GET /group/user/{channel}/chatters\u0026#34;) HystrixCommand\u0026lt;Chatters\u0026gt; getChatters( @Param(\u0026#34;channel\u0026#34;) String channelName ); Required Parameters\nName Type Description channelName text Target Channel Name Optional Parameters\nNone\nCode-Snippets print current viewers (chatters) Chatters chatters = twitchClient.getMessagingInterface().getChatters(\u0026#34;lirik\u0026#34;).execute(); System.out.println(\u0026#34;Broadcaster: \u0026#34; + chatters.getBroadcaster()); System.out.println(\u0026#34;VIPs: \u0026#34; + chatters.getVips()); System.out.println(\u0026#34;Mods: \u0026#34; + chatters.getModerators()); System.out.println(\u0026#34;Admins: \u0026#34; + chatters.getAdmins()); System.out.println(\u0026#34;Staff: \u0026#34; + chatters.getStaff()); System.out.println(\u0026#34;Viewers: \u0026#34; + chatters.getViewers()); System.out.println(\u0026#34;All Viewers (sum of the above): \u0026#34; + chatters.getAllViewers()); def chatters = twitchClient.messagingInterface.getChatters(\u0026#34;lirik\u0026#34;).execute(); System.out.println(\u0026#34;Broadcaster: ${chatters.broadcaster}\u0026#34;); System.out.println(\u0026#34;VIPs: ${chatters.vips}\u0026#34;); System.out.println(\u0026#34;Mods: ${chatters.moderators}\u0026#34;); System.out.println(\u0026#34;Admins: ${chatters.admins}\u0026#34;); System.out.println(\u0026#34;Staff: ${chatters.staff}\u0026#34;); System.out.println(\u0026#34;Viewers: ${chatters.viewers}\u0026#34;); System.out.println(\u0026#34;All Viewers (sum of the above): ${chatters.allViewers}\u0026#34;); val chatters = twitchClient.messagingInterface.getChatters(\u0026#34;lirik\u0026#34;).execute(); println(\u0026#34;Broadcaster: ${chatters.broadcaster}\u0026#34;); println(\u0026#34;VIPs: ${chatters.vips}\u0026#34;); println(\u0026#34;Mods: ${chatters.moderators}\u0026#34;); println(\u0026#34;Admins: ${chatters.admins}\u0026#34;); println(\u0026#34;Staff: ${chatters.staff}\u0026#34;); println(\u0026#34;Viewers: ${chatters.viewers}\u0026#34;); println(\u0026#34;All Viewers (sum of the above): ${chatters.allViewers}\u0026#34;); ","tags":null,"title":"TMI - Get Chatters","url":"/docs/rest-tmi/get-chatters/"},{"content":"Get Game Analytics Gets a URL that game developers can use to download analytics reports (CSV files) for their games. The URL is valid for 5 minutes. For detail about analytics and the fields returned, see the Insights \u0026amp; Analytics guide.\nThe response has a JSON payload with a data field containing an array of games information elements and can contain a pagination field containing information required to query for more streams.\nMethod Definition @RequestLine(\u0026#34;GET /analytics/games?after={after}\u0026amp;ended_at={ended_at}\u0026amp;first={first}\u0026amp;game_id={game_id}\u0026amp;started_at={started_at}\u0026amp;type={type}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;GameAnalyticsList\u0026gt; getGameAnalyticUrl( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;after\u0026#34;) String after, @Param(\u0026#34;first\u0026#34;) Integer limit, @Param(\u0026#34;game_id\u0026#34;) Long gameId, @Param(\u0026#34;type\u0026#34;) String type, @Param(\u0026#34;started_at\u0026#34;) String startedAt, @Param(\u0026#34;ended_at\u0026#34;) String endedAt ); Required Parameters\nName Type Description authToken string User Auth Token Optional Parameters\nName Type Description after string Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. This applies only to queries without extension_id. If an extension_id is specified, it supersedes any cursor/offset combinations. The cursor value specified here is from the pagination response field of a prior query. first string Maximum number of objects to return. Maximum: 100. Default: 20. type string Type of analytics report that is returned. If this is specified, the response includes one URL, for the specified report type. If this is not specified, the response includes multiple URLs (paginated), one for each report type available for the authenticated user’s Extensions. Limit: 1. Valid values: \u0026ldquo;overview_v1\u0026rdquo;, \u0026ldquo;overview_v2\u0026rdquo;. Default: all report types for the authenticated user’s Extensions. extension_id string Client ID value assigned to the extension when it is created. If this is specified, the returned URL points to an analytics report for just the specified extension. If this is not specified, the response includes multiple URLs (paginated), pointing to separate analytics reports for each of the authenticated user’s extensions. started_at string Starting date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z. This must be on or after January 31, 2018.If this is provided, ended_at also must be specified. If started_at is earlier than the default start date, the default date is used. Default: January 31, 2018 (overview_v2) or 90 days (overview_v1) before the report was issued. The file contains one row of data per day. ended_at string Ending date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z. The report covers the entire ending date; e.g., if 2018-05-01T00:00:00Z is specified, the report covers up to 2018-05-01T23:59:59Z. If this is provided, started_at also must be specified. If ended_at is later than the default end date, the default date is used. Default: 1-2 days before the request was issued (depending on report availability). Code-Snippets print report url (to download the files) ExtensionAnalyticsList resultList =twitchClient.getHelix().getGameAnalyticUrl(accessToken, null, 10, null, null, null, null).execute(); resultList.getGameAnalytics().forEach(analytic -\u0026gt; { System.out.println(\u0026#34;URL: \u0026#34; + analytic.getURL()); }); def resultList = twitchClient.helix.getGameAnalyticUrl(accessToken, null, 10, null, null, null, null).execute(); resultList.gameAnalytics.each { analytic -\u0026gt; System.out.println \u0026#34;URL: ${analytic.uRL}\u0026#34; } val resultList = twitchClient.helix.getGameAnalyticUrl(accessToken, null, 10, null, null, null, null).execute(); resultList.gameAnalytics.forEach { analytic -\u0026gt; println(\u0026#34;URL: ${analytic.uRL}\u0026#34;) } ","tags":null,"title":"Analytics - Game","url":"/docs/rest-helix/analytics-game-url/"},{"content":"Code Documentation The code of the project should be annotated with javadoc, so that we can create a automatic html docuementation and give helpful hints to users.\nWhen writing javadoc comments please follow this guideline:\nPunctuate every class and method description (sentence or phrase) with a period. Starting with an action word, describe what each class and method does. Avoid just restating the class or method name (e.g., Avoid updateLocalization(\u0026hellip;) → Updates the localization OR @param key the key). Describe the most important details in the first sentence, because it is the only one shown in the class/method summary. Include all relevant tags (@param, @return, etc) for each method; without them, the method Javadoc is incomplete. Start a method description with Returns, if the method returns a value. Don’t explicitly refer to collections in descriptions (e.g., list of articles). Use, instead, the plural (e.g., the articles) or “all the” (e.g., all the articles). When referring to another class, create a link by using {@link entity} (e.g., {@link TwitchClient}) Begin boolean parameter descriptions with whether. Describe exceptions (e.g., @throws) in past tense. Examples Class /** * Short Descriptions * \u0026lt;p\u0026gt; * Detailed Description * * @author First Person * @author Second Person * @version %I%, %G% * @since 1.11.0 */ public class Example {} Method /** * Returns a list of users who follow a specified channel, sorted by the date when they started following the channel (newest first, unless specified otherwise). * \u0026lt;p\u0026gt; * Requires Scope: none * * @param limit Maximum number of most-recent objects to return (users who started following the channel most recently). Default: 25. Maximum: none. * @param direction Direction of sorting. Valid values: asc (oldest first), desc (newest first). Default: desc. * @return Returns all followers. * @since 1.11.0 */ Observable\u0026lt;Follower\u0026gt; getFollowers(int limit, Direction direction); ","tags":null,"title":"Code Documentation","url":"/docs/contribution/code-documentation/"},{"content":"Get Hosts Description This endpoint returns a \u0026ldquo;host\u0026rdquo; record for each channel ID provided. If the channel is not hosting anyone, the target_id and target_login fields will not be present.\nMethod Definition @RequestLine(\u0026#34;GET /hosts?include_logins=1\u0026amp;host={id}\u0026#34;) HystrixCommand\u0026lt;HostList\u0026gt; getHosts( @Param(\u0026#34;id\u0026#34;) List\u0026lt;String\u0026gt; channelIds ); Required Parameters\nName Type Description channelIds text A list containing a user ID for each channel to check. Optional Parameters\nNone\nCode-Snippets print who a channel is hosting HostList hosts = twitchClient.getMessagingInterface().getHosts(Arrays.asList(\u0026#34;29829912\u0026#34;)).execute(); hosts.getHosts().forEach(host -\u0026gt; { System.out.println(host.getHostDisplayName() + \u0026#34; hosting \u0026#34; + host.getTargetDisplayName()); }); def hosts = twitchClient.messagingInterface.getHosts([\u0026#34;29829912\u0026#34;]).execute() hosts.hosts.each { host -\u0026gt; System.out.println \u0026#34;${host.hostDisplayName} hosting ${host.targetDisplayName}\u0026#34; } val hosts = twitchClient.messagingInterface.getHosts([\u0026#34;29829912\u0026#34;]).execute() hosts.hosts.each { host -\u0026gt; println(\u0026#34;${host.hostDisplayName} hosting ${host.targetDisplayName}\u0026#34;) } ","tags":null,"title":"TMI - Get Hosts","url":"/docs/rest-tmi/get-hosts/"},{"content":"Get Hosts of target channel Description This endpoint returns a \u0026ldquo;host\u0026rdquo; record for each channel hosting the channel with the provided targetId. It does not return the login of the target, only of the hosts. Therefore getTargetLogin will return null for each Host in HostList.getHosts().\nMethod Definition @RequestLine(\u0026#34;GET /hosts?include_logins=1\u0026amp;target={id}\u0026#34;) HystrixCommand\u0026lt;HostList\u0026gt; getHostsOf( @Param(\u0026#34;id\u0026#34;) String targetId ); Required Parameters\nName Type Description targetId text The user ID of the channel for which to get host information. Optional Parameters\nNone\nCode-Snippets print who is hosting a channel HostList hosts = twitchClient.getMessagingInterface().getHostsOf(\u0026#34;29829912\u0026#34;).execute(); hosts.getHosts().forEach(host -\u0026gt; { System.out.println(host.getHostDisplayName()); }); def hosts = twitchClient.messagingInterface.getHostsOf(\u0026#34;29829912\u0026#34;).execute() hosts.hosts.each { host -\u0026gt; System.out.println(host.hostDisplayName); } val hosts = twitchClient.messagingInterface.getHostsOf(\u0026#34;29829912\u0026#34;).execute() hosts.hosts.each { host -\u0026gt; println(host.hostDisplayName); } ","tags":null,"title":"TMI - Get Hosts of target channel","url":"/docs/rest-tmi/get-hosts-of/"},{"content":"Twitch PubSub PubSub enables you to subscribe to a topic, for updates (e.g., when a user cheers on a channel).\nThe Twitch PubSub system allows back-end services to broadcast realtime messages to clients. Example applications include:\nAn instant messaging service sending instant messages between friends. A back-end video system pushing real-time viewer count updates to video players. A presence system broadcasting users’ online status to all their friends. As Module: Twitch4J To use PubSub you need to enable the PubSub when building the Twitch4J Instance, as shown below:\nTwitchClient twitchClient = TwitchClientBuilder.builder() ... .withEnablePubSub(true) ... .build(); def twitchClient = TwitchClientBuilder.builder() ... .withEnablePubSub(true) ... .build() val twitchClient = TwitchClientBuilder.builder() ... .withEnablePubSub(true) ... .build() Standalone Initialize the PubSub as Standalone Module:\nTwitchPubSub client = TwitchPubSubBuilder.builder().build(); def client = TwitchPubSubBuilder.builder().build(); val client = TwitchPubSubBuilder.builder().build(); Handle the Results Messages received over PubSub will be dispatched using the EventManager, please see the Twitch4J -\u0026gt; Events Documentation on how to listen for events or check out the individual pages below for specific code samples.\nAvailable Topics In PubSub Context you subscribe to topics, a topic is for example whispers to user twitch4j or subscriptions in channel twitch4j.\nNote that nearly all of the pubsub topics rely upon the user ID to subscribe to them, rather than the user name. See API - Helix -\u0026gt; Users Get, if one needs to convert between the two.\nHere is a list of available topics along with code samples:\nOfficial Bits Badge Unlocks Bits Events Channel Points Events Commerce Events (Deprecated) Moderation Events Subscribe Events Whispers Unofficial Disclaimer: Use at your own risk after understanding the Twitch Developer Agreement. These topics may break at any time and there is no guarantee of support. The authors of the Twitch4J library assume no responsibility for your actions.\nFollowing Events Friendship Events Hype Train Events Hype Train Rewards Leaderboard Events Onsite Notifications Poll Events Presence Events Public Cheer Events Raid Events Sub Gift Events User Community Points Events Video Playback Events We hope Twitch will document these topics as there is no official way to get much of this data, and they could be used for creating powerful integrations.\nUnsubscribing Once a topic is no longer relevant, one can unsubscribe from it to stop receiving further events of that type.\n// Initial subscription PubSubSubscription subscription = twitchClient.getPubSub().listenForWhisperEvents(credential, userId); // Later unsubscription twitchClient.getPubSub().unsubscribeFromTopic(subscription); // Initial subscription def subscription = twitchClient.pubSub.listenForWhisperEvents(credential, userId) // Later unsubscription twitchClient.pubSub.unsubscribeFromTopic(subscription) // Initial subscription val subscription = twitchClient.pubSub.listenForWhisperEvents(credential, userId) // Later unsubscription twitchClient.pubSub.unsubscribeFromTopic(subscription) Rate-limits A single TwitchPubSub instance may only be subscribed to up to 50 topics at a time, under Twitch\u0026rsquo;s default limits. This yields another reason to unsubscribe from irrelevant topics; it creates headroom for other topics.\nIf still more headroom is needed, one can construct additional TwitchPubSub instances, each with a limit of 50 topics. Twitch recommends no greater than 10 pubsub connections be made from a single IP (each TwitchPubSub instance is equivalent to a single connection), but this is not a hard limit.\nTo simplify this, we offer TwitchPubSubConnectionPool as a class that can abstract away the creation/deletion of additional PubSub connections for you: // Create a dynamically-sized connection pool TwitchPubSubConnectionPool pool = TwitchPubSubConnectionPool.builder() .maxSubscriptionsPerConnection(50) .build(); // Register our listener(s) pool.getEventManager().onEvent(ChatModerationEvent.class, System.out::println); // Define our requests (that can exceed 50 in count) PubSubRequest req1 = ... ; PubSubRequest req2 = ... ; PubSubRequest req3 = ... ; // Subscribe to topics PubSubSubscription resp1 = pool.subscribe(req1); PubSubSubscription resp2 = pool.subscribe(req2); PubSubSubscription resp3 = pool.subscribe(req3); // Later, can unsubscribe from any pool.unsubscribe(resp2); // Create a dynamically-sized connection pool def pool = TwitchPubSubConnectionPool.builder() .maxSubscriptionsPerConnection(50) .build(); // Register our listener(s) pool.eventManager.onEvent(ChatModerationEvent) { System.out.println(it) } // Define our requests (that can exceed 50 in count) PubSubRequest req1 = ... PubSubRequest req2 = ... PubSubRequest req3 = ... // Subscribe to topics PubSubSubscription resp1 = pool.subscribe(req1) PubSubSubscription resp2 = pool.subscribe(req2) PubSubSubscription resp3 = pool.subscribe(req3) // Later, can unsubscribe from any pool.unsubscribe(resp2); // Create a dynamically-sized connection pool val pool = TwitchPubSubConnectionPool.builder() .maxSubscriptionsPerConnection(50) .build(); // Register our listener(s) pool.eventManager.onEvent(ChatModerationEvent::class.java, System.out::println); // Define our requests (that can exceed 50 in count) var req1: PubSubRequest = ... var req2: PubSubRequest = ... var req3: PubSubRequest = ... // Subscribe to topics val resp1: PubSubSubscription = pool.subscribe(req1) val resp2: PubSubSubscription = pool.subscribe(req2) val resp3: PubSubSubscription = pool.subscribe(req3) // Later, can unsubscribe from any pool.unsubscribe(resp2); A more concrete example of this can be found here.\n","tags":null,"title":"PubSub","url":"/docs/pubsub/"},{"content":"Get Cheermotes Description Retrieves the list of available Cheermotes, animated emotes to which viewers can assign Bits, to cheer in chat.\nMethod Definition @RequestLine(\u0026#34;GET /bits/cheermotes?broadcaster_id={broadcaster_id}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;CheermoteList\u0026gt; getCheermotes( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;broadcaster_id\u0026#34;) String broadcasterId ); Required Parameters\nName Type Description authToken string Auth Token Optional Query String Parameters\nName Type Description broadcaster_id string ID for the broadcaster who might own specialized Cheermotes. Code-Snippets print cheermotes image urls by tiers CheermoteList cheermoteList = twitchClient.getHelix().getCheermotes(authToken, \u0026#34;41245072\u0026#34;).execute(); cheermoteList.getCheermotes().forEach(cheermote -\u0026gt; { System.out.println(cheermote.getPrefix()); cheermote.getTiers().forEach(tier -\u0026gt; { System.out.println(tier.getId() + \u0026#34; \u0026#34; + tier.getImages().getLight().getAnimatedImages().getSize40()); }); }); def cheermoteList = twitchClient.helix.getCheermotes(authToken, \u0026#34;41245072\u0026#34;).execute(); cheermoteList.cheermotes.each { cheermote -\u0026gt; System.out.println cheermote.prefix cheermote.getTiers().each { tier -\u0026gt; System.out.println \u0026#34;${tier.id} ${tier.images.light.animatedImages.size40}\u0026#34; } } val cheermoteList = twitchClient.helix.getCheermotes(authToken, \u0026#34;41245072\u0026#34;).execute(); cheermoteList.cheermotes.forEach { cheermote -\u0026gt; println(cheermote.prefix) cheermote.getTiers().each { tier -\u0026gt; println(\u0026#34;${tier.id} ${tier.images.light.animatedImages.size40}\u0026#34;) } } ","tags":null,"title":"Bits - Get Cheermotes","url":"/docs/rest-helix/bits-cheermotes/"},{"content":"Get Bits Leaderboard Description Gets a ranked list of Bits leaderboard information for an authorized broadcaster.\nMethod Definition @RequestLine(\u0026#34;GET /bits/leaderboard?count={count}\u0026amp;period={period}\u0026amp;started_at={started_at}\u0026amp;user_id={user_id}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;BitsLeaderboard\u0026gt; getBitsLeaderboard( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;count\u0026#34;) String count, @Param(\u0026#34;period\u0026#34;) String period, @Param(\u0026#34;started_at\u0026#34;) String startedAt, @Param(\u0026#34;user_id\u0026#34;) Long userId ); Required Parameters\nName Type Description authToken string User Auth Token Optional Parameters\nName Type Description count string Number of results to be returned. Maximum: 100. Default: 10. period string Time period over which data is aggregated (PST time zone). This parameter interacts with started_at. Valid values are given below. Default: \u0026quot;all\u0026quot;.\u0026ldquo;day\u0026rdquo; – 00:00:00 on the day specified in started_at, through 00:00:00 on the following day.\u0026lt;br /*\u0026ldquo;week\u0026rdquo; – 00:00:00 on Monday of the week specified in started_at, through 00:00:00 on the following Monday.\u0026ldquo;month\u0026rdquo; – 00:00:00 on the first day of the month specified in started_at, through 00:00:00 on the first day of the following month.\u0026ldquo;year\u0026rdquo; – 00:00:00 on the first day of the year specified in started_at, through 00:00:00 on the first day of the following year.\u0026ldquo;all\u0026rdquo; – The lifetime of the broadcaster\u0026rsquo;s channel. If this is specified (or used by default), started_at is ignored. started_at string Timestamp for the period over which the returned data is aggregated. Must be in RFC 3339 format. If this is not provided, data is aggregated over the current period; e.g., the current day/week/month/year. This value is ignored if period is \u0026ldquo;all\u0026rdquo;.Any + operator should be URL encoded.Currently, the HH:MM:SS part of this value is used only to identify a given day in PST and otherwise ignored. For example, if the started_at value resolves to 5PM PST yesterday and period is \u0026ldquo;day\u0026rdquo;, data is returned for all of yesterday. user_id string ID of the user whose results are returned; i.e., the person who paid for the Bits.As long as count is greater than 1, the returned data includes additional users, with Bits amounts above and below the user specified by user_id.If user_id is not provided, the endpoint returns the Bits leaderboard data across top users (subject to the value of count). Code-Snippets print ranking BitsLeaderboard resultList = twitchClient.getHelix().getBitsLeaderboard(accessToken, \u0026#34;10\u0026#34;, \u0026#34;all\u0026#34;, null, null).execute(); resultList.getEntries().forEach(entry -\u0026gt; { System.out.println(entry.getRank() + \u0026#34;: \u0026#34; + entry.getUserId()); }); def resultList = twitchClient.helix.getBitsLeaderboard(accessToken, \u0026#34;10\u0026#34;, \u0026#34;all\u0026#34;, null, null).execute(); resultList.entries.each { entry -\u0026gt; System.out.println \u0026#34;${entry.rank}: ${entry.userId}\u0026#34; } val resultList = twitchClient.helix.getBitsLeaderboard(accessToken, \u0026#34;10\u0026#34;, \u0026#34;all\u0026#34;, null, null).execute(); resultList.entries.forEach { entry -\u0026gt; println(\u0026#34;${entry.rank}: ${entry.userId}\u0026#34;); } ","tags":null,"title":"Bits - Leaderboard","url":"/docs/rest-helix/bits-leaderboard/"},{"content":"Get Code Status Description Gets the status of one or more provided codes.\nMethod Definition @RequestLine(\u0026#34;GET /entitlements/codes?code={code}\u0026amp;user_id={user_id}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;CodeStatusList\u0026gt; getCodeStatus( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;code\u0026#34;) List\u0026lt;String\u0026gt; code, @Param(\u0026#34;user_id\u0026#34;) Integer userId ); Required Parameters\nName Type Description authToken string App Access Token code string The code to get the status of. userId integer Represents a numeric Twitch user ID Code-Snippets print code status CodeStatusList codeStatusList = twitchClient.getHelix().getCodeStatus(authToken, Arrays.asList(\u0026#34;KUHXV-4GXYP-AKAKK\u0026#34;), 156900877).execute(); codeStatusList.getStatuses().forEach(codeStatus -\u0026gt; { System.out.println(codeStatus.getCode() + \u0026#34; \u0026#34; + codeStatus.getStatus()); }); def codeStatusList = twitchClient.helix.getCodeStatus(authToken, [\u0026#34;KUHXV-4GXYP-AKAKK\u0026#34;], 156900877).execute(); codeStatusList.statuses.each { codeStatus -\u0026gt; System.out.println \u0026#34;${codeStatus.code} ${codeStatus.status}\u0026#34; } val codeStatusList = twitchClient.helix.getCodeStatus(authToken, listOf(\u0026#34;KUHXV-4GXYP-AKAKK\u0026#34;), 156900877).execute(); codeStatusList.statuses.forEach { codeStatus -\u0026gt; println(\u0026#34;${codeStatus.code} ${codeStatus.status}\u0026#34;) } ","tags":null,"title":"Entitlements - Get Code Status","url":"/docs/rest-helix/entitlements-codes/"},{"content":"Redeem Code Description Redeems one or more provided codes to the authenticated Twitch user.\nMethod Definition @RequestLine(\u0026#34;POST /entitlements/codes?code={code}\u0026amp;user_id={user_id}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;CodeStatusList\u0026gt; redeemCode( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;code\u0026#34;) List\u0026lt;String\u0026gt; code, @Param(\u0026#34;user_id\u0026#34;) Integer userId ); Required Parameters\nName Type Description authToken string App Access Token code string The code to redeem to the authenticated user’s account. userId integer Represents a numeric Twitch user ID Code-Snippets redeem code and print status CodeStatusList codeStatusList = twitchClient.getHelix().redeemCode(authToken, Arrays.asList(\u0026#34;KUHXV-4GXYP-AKAKK\u0026#34;), 156900877).execute(); codeStatusList.getStatuses().forEach(codeStatus -\u0026gt; { System.out.println(codeStatus.getCode() + \u0026#34; \u0026#34; + codeStatus.getStatus()); }); def codeStatusList = twitchClient.helix.redeemCode(authToken, [\u0026#34;KUHXV-4GXYP-AKAKK\u0026#34;], 156900877).execute() codeStatusList.statuses.each { codeStatus -\u0026gt; System.out.println(\u0026#34;${codeStatus.code} ${codeStatus.status}\u0026#34;) } val codeStatusList = twitchClient.helix.redeemCode(authToken, listOf(\u0026#34;KUHXV-4GXYP-AKAKK\u0026#34;), 156900877).execute() codeStatusList.statuses.forEach { codeStatus -\u0026gt; println(\u0026#34;${codeStatus.code} ${codeStatus.status}\u0026#34;) } ","tags":null,"title":"Entitlements - Redeem Code","url":"/docs/rest-helix/entitlements-redeem-codes/"},{"content":"Logging You can use any logging framework of your choice with Twitch4J, but you have to add at least one so that logging works correctly.\nIf you do not ad at least one, you will see the following output:\nSLF4J: Failed to load class \u0026#34;org.slf4j.impl.StaticLoggerBinder\u0026#34;. SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details. Here are a few examples on how to add a logging library of your choice:\nLibrary: Logback dependencies { implementation group: \u0026#39;ch.qos.logback\u0026#39;, name: \u0026#39;logback-classic\u0026#39;, version: \u0026#39;1.2.10\u0026#39; } dependencies { implementation(group = \u0026#34;ch.qos.logback\u0026#34;, name = \u0026#34;logback-classic\u0026#34;, version = \u0026#34;1.2.10\u0026#34;) } \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; And place a configuration file logback.xml into src/main/resources. This is the place you can use to configure logging:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration scan=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- Configure Twitch4J logger level --\u0026gt; \u0026lt;logger name=\u0026#34;com.github.twitch4j\u0026#34; level=\u0026#34;INFO\u0026#34;/\u0026gt; \u0026lt;!-- Appender Configuration [Console] --\u0026gt; \u0026lt;appender name=\u0026#34;CONSOLE\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%d{HH:mm:ss.SSS} [%thread] %highlight([%-5level]) %logger{25} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- Appender Configuration [File] --\u0026gt; \u0026lt;appender name=\u0026#34;FILE\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;file\u0026gt;client.log\u0026lt;/file\u0026gt; \u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.FixedWindowRollingPolicy\u0026#34;\u0026gt; \u0026lt;fileNamePattern\u0026gt;client.%i.log\u0026lt;/fileNamePattern\u0026gt; \u0026lt;/rollingPolicy\u0026gt; \u0026lt;triggeringPolicy class=\u0026#34;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\u0026#34;\u0026gt; \u0026lt;MaxFileSize\u0026gt;10MB\u0026lt;/MaxFileSize\u0026gt; \u0026lt;/triggeringPolicy\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- Appender Output Configuration --\u0026gt; \u0026lt;root level=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;CONSOLE\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt; This sample only logs to the console, you can change the appender-ref from CONSOLE to FILE to use file-based logging with rotation - refer to the logback documentation for further customization options.\n","tags":null,"title":"Logging","url":"/docs/getting-started/logging/"},{"content":"User - Follow Description Follow a user on twitch (and turn of notifications if desired).\nMethod Definition Required Parameters\nName Type Description authToken string User Auth Token targetUserId number Target User Id notification boolean Enable notifications? Optional Parameters\nNone\nCode-Snippets follow a user (without notifications) twitchClient.getGraphQL().followUser(credential, 24943033l, false).execute(); twitchClient.graphQL.followUser(credential, 24943033l, false).execute() twitchClient.graphQL.followUser(credential, 24943033l, false).execute() follow a user (with notifications) twitchClient.getGraphQL().followUser(credential, 24943033l, true).execute(); twitchClient.graphQL.followUser(credential, 24943033l, true).execute() twitchClient.graphQL.followUser(credential, 24943033l, true).execute() ","tags":null,"title":"User - Follow","url":"/docs/graphql/user-follow/"},{"content":"User - Unfollow Description Unfollow a user on twitch.\nMethod Definition Required Parameters\nName Type Description authToken string User Auth Token targetUserId number Target User Id Optional Parameters\nNone\nCode-Snippets unfollow a user twitchClient.getGraphQL().unfollowUser(credential, 24943033l).execute(); twitchClient.graphQL.unfollowUser(credential, 24943033l).execute() twitchClient.graphQL.unfollowUser(credential, 24943033l).execute() ","tags":null,"title":"User - Unfollow","url":"/docs/graphql/user-unfollow/"},{"content":"Create Clip Description Creates a clip programmatically. This returns both an ID and an edit URL for the new clip.\nClip creation takes time. We recommend that you query Get Clips, with the clip ID that is returned here. If Get Clips returns a valid clip, your clip creation was successful. If, after 15 seconds, you still have not gotten back a valid clip from Get Clips, assume that the clip was not created and retry Create Clip.\nThis endpoint has a global rate limit, across all callers. The limit may change over time, but the response includes informative headers:\nRatelimit-Helixclipscreation-Limit: \u0026lt;int value\u0026gt; Ratelimit-Helixclipscreation-Remaining: \u0026lt;int value\u0026gt; Method Definition @RequestLine(\u0026#34;POST /clips?broadcaster_id={broadcaster_id}\u0026amp;has_delay={has_delay}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;CreateClipList\u0026gt; createClip( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;broadcaster_id\u0026#34;) String broadcasterId, @Param(\u0026#34;has_delay\u0026#34;) Boolean hasDelay ); Required Parameters\nName Type Description authToken string User Auth Token Optional Query String Parameters\nName Type Description broadcaster_id string ID of the stream from which the clip will be made. has_delay string If false, the clip is captured from the live stream when the API is called; otherwise, a delay is added before the clip is captured (to account for the brief delay between the broadcaster’s stream and the viewer’s experience of that stream). Default: false. Code-Snippets create clip and show id CreateClipList clipData = twitchClient.getHelix().createClip(accessToken, \u0026#34;149223493\u0026#34;, false).execute(); clipData.getData().forEach(clip -\u0026gt; { System.out.println(\u0026#34;Created Clip with ID: \u0026#34; + clip.getId()); }); def clipData = twitchClient.helix.createClip(accessToken, \u0026#34;149223493\u0026#34;, false).execute(); clipData.data.each { clip -\u0026gt; System.out.println \u0026#34;Created Clip with ID: ${clip.id}\u0026#34; } val clipData = twitchClient.helix.createClip(accessToken, \u0026#34;149223493\u0026#34;, false).execute(); clipData.`data`.each { clip -\u0026gt; println(\u0026#34;Created Clip with ID: ${clip.id}\u0026#34;) } ","tags":null,"title":"Clips - Create","url":"/docs/rest-helix/clips-create/"},{"content":"Get Clips Description Gets clip information by clip ID (one or more), broadcaster ID (one only), or game ID (one only).\nThe response has a JSON payload with a data field containing an array of clip information elements and a pagination field containing information required to query for more streams.\nMethod Definition @RequestLine(\u0026#34;GET /clips?broadcaster_id={broadcaster_id}\u0026amp;game_id={game_id}\u0026amp;id={id}\u0026amp;after={after}\u0026amp;before={before}\u0026amp;first={first}\u0026amp;started_at={started_at}\u0026amp;ended_at={ended_at}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;ClipList\u0026gt; getClips( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;broadcaster_id\u0026#34;) Long broadcasterId, @Param(\u0026#34;game_id\u0026#34;) String gameId, @Param(\u0026#34;id\u0026#34;) String id, @Param(\u0026#34;after\u0026#34;) String after, @Param(\u0026#34;before\u0026#34;) String before, @Param(\u0026#34;first\u0026#34;) Integer limit, @Param(\u0026#34;started_at\u0026#34;) Date startedAt, @Param(\u0026#34;ended_at\u0026#34;) Date endedAt ); Required Parameters (one of)\nName Type Description broadcaster_id string ID of the broadcaster for whom clips are returned. The number of clips returned is determined by the first query-string parameter (default: 20). Results are ordered by view count. game_id string ID of the game for which clips are returned. The number of clips returned is determined by the first query-string parameter (default: 20). Results are ordered by view count. id string ID of the clip being queried. Limit: 100. Optional Parameters\nName Type Description authToken string User Auth Token after string Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. This applies only to queries specifying broadcaster_id or game_id. The cursor value specified here is from the pagination response field of a prior query. before string Cursor for backward pagination: tells the server where to start fetching the next set of results, in a multi-page response. This applies only to queries specifying broadcaster_id or game_id. The cursor value specified here is from the pagination response field of a prior query. first string Maximum number of objects to return. Maximum: 100. Default: 20. started_at string Starting date/time for returned clips, in RFC3339 format. (Note that the seconds value is ignored.) If this is specified, ended_at also should be specified; otherwise, the ended_at date/time will be 1 week after the started_at value. ended_at string Ending date/time for returned clips, in RFC3339 format. (Note that the seconds value is ignored.) If this is specified, started_at also must be specified; otherwise, the time period is ignored. Code-Snippets print clip id\u0026rsquo;s ClipList clipList = twitchClient.getHelix().getClips(null, \u0026#34;488552\u0026#34;, null, null, null, null, null, null).execute(); clipList.getData().forEach(clip -\u0026gt; { System.out.println(\u0026#34;Found Clip: \u0026#34; + clip.getId()); }); def clipList = twitchClient.helix.getClips(null, \u0026#34;488552\u0026#34;, null, null, null, null, null, null).execute(); clipList.data.each { clip -\u0026gt; System.out.println \u0026#34;Found Clip: ${clip.id}\u0026#34; } val clipList = twitchClient.helix.getClips(null, \u0026#34;488552\u0026#34;, null, null, null, null, null, null).execute(); clipList.`data`.forEach { clip -\u0026gt; println(\u0026#34;Found Clip: ${clip.id}\u0026#34;) } ","tags":null,"title":"Clips - Get","url":"/docs/rest-helix/clips-get/"},{"content":"Get Games Description Gets game information by game ID or name.\nThe response has a JSON payload with a data field containing an array of games elements.\nMethod Definition @RequestLine(\u0026#34;GET /games?id={id}\u0026amp;name={name}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;GameList\u0026gt; getGames( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;id\u0026#34;) List\u0026lt;Long\u0026gt; id, @Param(\u0026#34;name\u0026#34;) List\u0026lt;String\u0026gt; name ); Required Parameters\nName Type Description id string Game ID. At most 100 id values can be specified name string Game name. The name must be an exact match. For instance, “Pokemon” will not return a list of Pokemon games; instead, query the specific Pokemon game(s) in which you are interested. At most 100 name values can be specified. Optional Parameters\nName Type Description authToken string User Auth Token Code-Snippets print game name GameList resultList = twitchClient.getHelix().getGames(Arrays.asList(overwatchGameId), null).execute(); resultList.getGames().forEach(game -\u0026gt; { System.out.println(\u0026#34;Game ID: \u0026#34; + game.getId() + \u0026#34; is \u0026#34; + game.getName()); }); def resultList = twitchClient.helix.getGames([overwatchGameId], null).execute() resultList.games.each { game -\u0026gt; System.out.println \u0026#34;Game ID: ${game.id} is ${game.name}\u0026#34; } val resultList = twitchClient.helix.getGames(listOf(overwatchGameId), null).execute() resultList.games.forEach { game -\u0026gt; println(\u0026#34;Game ID: ${game.id} is ${game.name}\u0026#34;) } ","tags":null,"title":"Games - Get","url":"/docs/rest-helix/games-get/"},{"content":"Get Top Games Description Gets games sorted by number of current viewers on Twitch, most popular first.\nThe response has a JSON payload with a data field containing an array of games information elements and a pagination field containing information required to query for more streams.\nMethod Definition @RequestLine(\u0026#34;GET /games/top?after={after}\u0026amp;before={before}\u0026amp;first={first}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;GameTopList\u0026gt; getTopGames( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;after\u0026#34;) String after, @Param(\u0026#34;before\u0026#34;) String before, @Param(\u0026#34;first\u0026#34;) String first ); Required Parameters\nNone\nOptional Parameters\nName Type Description authToken string User Auth Token after string Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. before string Cursor for backward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. first string Maximum number of objects to return. Maximum: 100. Default: 20. Code-Snippets print game id and name for the top 10 games GameTopList resultList = twitchClient.getHelix().getTopGames(null, null, 10).execute(); resultList.getGames().forEach(game -\u0026gt; { System.out.println(\u0026#34;ID: \u0026#34; + game.getId() + \u0026#34; - \u0026#34; + game.getName()); }); def resultList = twitchClient.helix.getTopGames(null, null, 10).execute() resultList.games.each { game -\u0026gt; System.out.println \u0026#34;ID: ${game.id} - ${game.name}\u0026#34; } val resultList = twitchClient.helix.getTopGames(null, null, 10).execute() resultList.games.forEach { game -\u0026gt; println(\u0026#34;ID: ${game.id} - ${game.name}\u0026#34;) } ","tags":null,"title":"Games - Top Games","url":"/docs/rest-helix/games-top/"},{"content":"Get Moderators Description Returns all moderators in a channel.\nMethod Definition @RequestLine(value = \u0026#34;GET /moderation/moderators?broadcaster_id={broadcaster_id}\u0026amp;user_id={user_id}\u0026amp;after={after}\u0026#34;, collectionFormat = CollectionFormat.CSV) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;ModeratorList\u0026gt; getModerators( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;broadcaster_id\u0026#34;) String broadcasterId, @Param(\u0026#34;user_id\u0026#34;) List\u0026lt;String\u0026gt; userIds, @Param(\u0026#34;after\u0026#34;) String after ); Required Parameters\nName Type Description authToken string User Token for the broadcaster (scope: moderation:read) broadcasterId string Provided broadcaster_id must match the user_id in the auth token. Optional Parameters\nName Type Description userIds string Filters the results and only returns a status object for users who are moderators in this channel and have a matching user_id. after string Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. Code-Snippets print list of moderators ModeratorList resultList = twitchClient.getHelix().getModerators(authToken, broadcasterId, null, null).execute(); resultList.getModerators().forEach(moderator -\u0026gt; { System.out.println(moderator); }); def resultList = twitchClient.helix.getModerators(authToken, broadcasterId, null, null).execute() resultList.moderators.each { moderator -\u0026gt; System.out.println moderator } val resultList = twitchClient.helix.getModerators(authToken, broadcasterId, null, null).execute() resultList.moderators.forEach { moderator -\u0026gt; println(moderator) } ","tags":null,"title":"Moderators - Get","url":"/docs/rest-helix/moderators-get/"},{"content":"Get Moderator Events Description Returns a list of moderators or users added and removed as moderators from a channel.\nMethod Definition @RequestLine(value = \u0026#34;GET /moderation/moderators/events?broadcaster_id={broadcaster_id}\u0026amp;user_id={user_id}\u0026amp;after={after}\u0026#34;, collectionFormat = CollectionFormat.CSV) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;ModeratorEventList\u0026gt; getModeratorEvents( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;broadcaster_id\u0026#34;) String broadcasterId, @Param(\u0026#34;user_id\u0026#34;) List\u0026lt;String\u0026gt; userIds, @Param(\u0026#34;after\u0026#34;) String after ); Required Parameters\nName Type Description authToken string User Token for the broadcaster (scope: moderation:read) broadcasterId string Provided broadcaster_id must match the user_id in the auth token. Optional Parameters\nName Type Description userIds string Filters the results and only returns a status object for users who are moderators in this channel and have a matching user_id. after string Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. Code-Snippets print list of moderator events ModeratorEventList resultList = twitchClient.getHelix().getModeratorEvents(authToken, broadcasterId, null, null).execute(); resultList.getEvents().forEach(event -\u0026gt; { System.out.println(event); }); def resultList = twitchClient.helix.getModeratorEvents(authToken, broadcasterId, null, null).execute() resultList.events.each { event -\u0026gt; System.out.println event } val resultList = twitchClient.helix.getModeratorEvents(authToken, broadcasterId, null, null).execute() resultList.events.forEach { event -\u0026gt; println(event) } ","tags":null,"title":"Moderators - Get Events","url":"/docs/rest-helix/moderators-get-events/"},{"content":"Get Users Description Gets a list of specified user objects.\nThis is a legacy method which is still included, because helix does not provide the user creation date yet.\nMethod Definition @RequestLine(\u0026#34;GET /users?login={logins}\u0026#34;) @Headers({ \u0026#34;Accept: application/vnd.twitchtv.v5+json\u0026#34; }) HystrixCommand\u0026lt;KrakenUserList\u0026gt; getUsersByLogin( @Param(\u0026#34;logins\u0026#34;) List\u0026lt;String\u0026gt; logins\t); Required Parameters\nName Type Description logins text User login name (lower case channelname/username). Multiple login names can be specified. Limit: 100. None\nOptional Parameters\nNone\nCode-Snippets get information about a single user KrakenUserList resultList = twitchClient.getKraken().getUsersByLogin(Arrays.asList(\u0026#34;twitch4j\u0026#34;)).execute(); def resultList = twitchClient.kraken.getUsersByLogin([\u0026#34;twitch4j\u0026#34;]).execute() val resultList = twitchClient.kraken.getUsersByLogin(listOf(\u0026#34;twitch4j\u0026#34;)).execute() ","tags":null,"title":"Users - Get","url":"/docs/rest-kraken/user-get/"},{"content":"Get Channel Subscribers Description Gets a list of users subscribed to a specified channel, sorted by the date when they subscribed.\nMethod Definition @RequestLine(\u0026#34;GET /channels/{channelId}/subscriptions?limit={limit}\u0026amp;offset={offset}\u0026amp;direction={direction}\u0026#34;) @Headers({ \u0026#34;Authorization: OAuth {token}\u0026#34;, \u0026#34;Accept: application/vnd.twitchtv.v5+json\u0026#34; }) HystrixCommand\u0026lt;KrakenSubscriptionList\u0026gt; getChannelSubscribers( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;channelId\u0026#34;) Long channelId, @Param(\u0026#34;limit\u0026#34;) Integer limit, @Param(\u0026#34;offset\u0026#34;) Integer offset, @Param(\u0026#34;direction\u0026#34;) String direction ); Required Parameters\nName Type Description authToken string Authentication Token with scope channel_subscriptions for the target channel channelId long Target Channel Id Optional Parameters\nName Type Description limit integer Maximum number of objects to return. Default: 25. Maximum: 100. offset integer Object offset for pagination of results. Default: 0. direction string Sorting direction. Valid values: asc, desc. Default: asc (oldest first). Code-Snippets print 25 subscribers of a channel (first page) KrakenSubscriptionList resultList = twitchClient.getKraken().getChannelSubscribers(\u0026#34;accessToken\u0026#34;, channelId, null, null, null).execute(); resultList.getSubscriptions().forEach(sub -\u0026gt; { System.out.println(sub.toString()); }); def resultList = twitchClient.kraken.getChannelSubscribers(\u0026#34;accessToken\u0026#34;, channelId, null, null, null).execute(); resultList.subscriptions.each { sub -\u0026gt; System.out.println \u0026#34;$sub\u0026#34; } val resultList = twitchClient.kraken.getChannelSubscribers(\u0026#34;accessToken\u0026#34;, channelId, null, null, null).execute(); resultList.subscriptions.forEach { sub -\u0026gt; println(\u0026#34;$sub\u0026#34;) } ","tags":null,"title":"Channel - Get Subscriptions","url":"/docs/rest-kraken/channel-get-subscribers/"},{"content":"Documentation Documentation content is builded via Hugo, using own styling colors combined with Brand Assets guidelines colors and Bootstrap 4 assets (delivered from package.json). For search engine we are using Fuse.js. All content are be cloneable from this page.\nConfiguration Using config.yml we define a custom menu content\u0026hellip; and the other stuff.\nWrite your documentation To write documentation propertly use:\nFront Matter template\nfor specific child --- title: A page title weight: (next iterable number) menu: docs: parent: A parent page title --- for new parent --- title: A page title weight: (next iterable number) menu: docs --- There is no need specify layout of documentation for the new parent docs.\nSpecified shortcodes (if some nessecarly)\nCurrently defined shortcodes All shortcodes are supported only on content directory. More about how to use shortcodes go to Hugo Documentation. You have currently defined shortcodes below.\nAlert Simple definition alert \u0026lt;color\u0026gt;:\n\u0026lt;color\u0026gt; - color specific. This is info message This is alert with Twitch Purple colored message Blockquote blockqoute \u0026lt;author\u0026gt;\nauthor - author of the quote or something else (Optional) Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse rhoncus at felis ac congue. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aenean tincidunt eleifend nunc, sed tincidunt nibh interdum eget. In fermentum purus ac arcu finibus, et accumsan est tincidunt. Duis bibendum orci tellus, tempor aliquam nisl elementum nec. Phasellus pulvinar, ante non dictum pharetra, urna risus vehicula nisl, at cursus ipsum augue id risus. Phasellus quis nulla felis. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nullam tristique, lacus ut congue dictum, nibh risus finibus nisl, quis ultrices lacus tellus faucibus libero. Curabitur vel ultrices mi.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse rhoncus at felis ac congue. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aenean tincidunt eleifend nunc, sed tincidunt nibh interdum eget. In fermentum purus ac arcu finibus, et accumsan est tincidunt. Duis bibendum orci tellus, tempor aliquam nisl elementum nec. Phasellus pulvinar, ante non dictum pharetra, urna risus vehicula nisl, at cursus ipsum augue id risus. Phasellus quis nulla felis. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nullam tristique, lacus ut congue dictum, nibh risus finibus nisl, quis ultrices lacus tellus faucibus libero. Curabitur vel ultrices mi.\nTwitch4J Button button type=\u0026quot;\u0026lt;type\u0026gt;\u0026quot;\ntype - button / link - default: link (Optional) href - url, only on type=link btn_type - button type, only on type=button disabled - mark your button as disabled size - your button size, following by bootstrap documentation: sm, md, lg, etc. outline - create button with outline color - button color Examples if type is not defined the button shortcode generates button as link\nButton 1 Of course you can made him as ordinal button but you need define btn_type as type of button\nSubmit There is more features like size (sm, md, lg), outline, disabled, colors, etc.\nOutline Button Disabled Button Code Blocks / Build Blocks For easing our library usage we recommend write it with codeblocks. Difference between code and build is usage:\ncode is for library examples build is for build examples booth of them are independent from sharable tab content. Each of them will remember it which tab the user choose.\nSingle and simple (with markdown) If you are using single language code block just only like this?\npublic class Application { public static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); } } Using shortcode putting code via shortcode code \u0026lt;name\u0026gt;\nname - codeblock name - Required Just simple The name it will be right side of the code. That is recommended to naming the code as the file name.\npublic class Application { public static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); } } Codeblock with tabs You wanna trying some multiple languages like: java and kotlin here is some helpful example:\npublic class Application { public static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); } } class Application { static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); } } fun main(args: Array\u0026lt;String\u0026gt;) { println(\u0026#34;Hello World!\u0026#34;); } Using builds Same rules like a Codeblock with tabs, but:\ncodeblocks shortcode rename to builds code \u0026lt;Language\u0026gt; shortcode rename to build \u0026lt;name\u0026gt; name is build named specific (gradle,kotlin,pom) gradle for build.gradle kotlin for build.gradle.kts pom for pom.xml Example plugins { id \u0026#34;java-library\u0026#34; id \u0026#34;maven-publish\u0026#34; } depdendencies { implementation \u0026#34;com.github.twitch4j:twitch4j:1.0.0\u0026#34; } plugins { `java-library` `maven-publish` } depdendencies { implementation(\u0026#34;com.github.twitch4j:twitch4j:1.0.0\u0026#34;) } \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.twitch4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;twitch4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Additional Notes The build example shows only currently supported builds. In the near future we can expand to the other build tools.\nColumn sizes Using Grid System provided by Bootstrap we can define flexible columns for responsive size.\ncol \u0026lt;size...\u0026gt;\nsize - using by grid options we can specify only sizes divided of 12 columns on current row. in example col 12 md-6 we get context in the half on the container and the whole container size content below 720px. See: grid options Spoiler The content which you wanna hide it spoiler \u0026lt;name\u0026gt;\nname spoiler name (optional) Spoiler This is content to hide. Example This is content to hide. Color Currently avaliable colors are followed up by the Bootstrap documentation\nAdditiona Avaliable Colors followed up by Brand Asset Guidelines:\n- black-ops - twitch-purple - ice - jiggle - worm - isabelle - droid - wipe-out - smoke - widow - peach - pac-man - felicia - sonic - dragon - cuddle - bandit - lightning - ko - mega - nights - osu - sniper - egg - legend - zero Additional Notes To before starting editing documentation you needs\nhugo - to generate this page node - to install and deliver those packages IMPORTANT: This readme is not a part of the content generated by hugo.\nLive View To editing this project type in project console npm start or hugo server\nGenerate files To generate ready to deploy project just type in project console npm run generate or npm run generate:minify. All content are be generated in: public folder.\nGitHub Actions Project will automatically generate files and push them into gh-pages branch. To define own configuration please go to .github/workflows/gh-pages.yml and follow those useful documentation:\nGithub Actions Documentation GitHub Actions for GitHub Pages GitHub Actions for Hugo ","tags":null,"title":"Documentation","url":"/docs/contribution/documentation/"},{"content":"Get Streams Description Gets information about active streams. Streams are returned sorted by number of current viewers, in descending order. Across multiple pages of results, there may be duplicate or missing streams, as viewers join and leave streams.\nThe response has a JSON payload with a data field containing an array of stream information elements and a pagination field containing information required to query for more streams.\nMethod Definition @RequestLine(\u0026#34;GET /streams?after={after}\u0026amp;before={before}\u0026amp;first={first}\u0026amp;game_id={game_id}\u0026amp;language={language}\u0026amp;user_id={user_id}\u0026amp;user_login={user_login}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;StreamList\u0026gt; getStreams( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;after\u0026#34;) String after, @Param(\u0026#34;before\u0026#34;) String before, @Param(\u0026#34;first\u0026#34;) Integer limit, @Param(\u0026#34;game_id\u0026#34;) List\u0026lt;String\u0026gt; gameIds, @Param(\u0026#34;language\u0026#34;) List\u0026lt;String\u0026gt; language, @Param(\u0026#34;user_id\u0026#34;) List\u0026lt;String\u0026gt; userIds, @Param(\u0026#34;user_login\u0026#34;) List\u0026lt;String\u0026gt; userLogins ); Required Parameters\nName Type Description authToken string User or App Access Token As with all Helix endpoints, twitch requires an oauth token. If when using TwitchHelixBuilder, a valid client id/secret pair or defaultAuthToken was specified, then this can be set to null.\nOptional Parameters\nName Type Description after string Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. before string Cursor for backward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. limit integer Maximum number of objects to return. Maximum: 100. Default: 20. game_id string Returns streams broadcasting a specified game ID. You can specify up to 100 IDs. language string Stream language. You can specify up to 100 languages. user_id string Returns streams broadcast by one or more specified user IDs. You can specify up to 100 IDs. user_login string Returns streams broadcast by one or more specified user login names. You can specify up to 100 names. Code-Snippets get the top 5 streams StreamList resultList = twitchClient.getHelix().getStreams(null, null, null, 5, null, null, null, null).execute(); resultList.getStreams().forEach(stream -\u0026gt; { System.out.println(\u0026#34;ID: \u0026#34; + stream.getId() + \u0026#34; - Title: \u0026#34; + stream.getTitle()); }); def resultList = twitchClient.helix.getStreams(null, null, null, 5, null, null, null, null).execute() resultList.streams.each { stream -\u0026gt; System.out.println \u0026#34;ID: ${stream.id} - Title: ${stream.title}\u0026#34; } val resultList = twitchClient.helix.getStreams(null, null, null, 5, null, null, null, null).execute() resultList.streams.forEach { stream -\u0026gt; println(\u0026#34;ID: ${stream.id} - Title: ${stream.title}\u0026#34;) } ","tags":null,"title":"Streams - Get","url":"/docs/rest-helix/streams-get/"},{"content":"Topic - Bits Badge Unlocks Description This topic can be used to monitor whenever a new bits badge tier is unlocked by a user cheering in a specified channel.\nMethod Definition Required Parameters\nName Type Description credential OAuth2Credential User Auth Token for the target channel id, with the scope bits:read channelId String Target Channel Id Optional Parameters\nNone\nCode-Snippets Subscribe to all bits badge unlocks in the twitch4j channel and register a listener that prints all messages to console\ntwitchClient.getPubSub().listenForBitsBadgeEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getEventManager().getEventHandler(ChannelBitsBadgeUnlockEvent.class).onEvent(ChannelSubscribeEvent.class, System.out::println); twitchClient.pubSub.listenForBitsBadgeEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.getEventHandler(ChannelBitsBadgeUnlockEvent).onEvent(ChannelSubscribeEvent, System.out::println) twitchClient.pubSub.listenForBitsBadgeEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.getEventHandler(ChannelBitsBadgeUnlockEvent::class.java).onEvent(ChannelSubscribeEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Bits Badge Unlocks","url":"/docs/pubsub/topic-bits-badge-unlocks/"},{"content":"Topic - Bits Events Description This topic can be used to monitor whenever bits are cheered in a specified channel.\nMethod Definition Required Parameters\nName Type Description credential OAuth2Credential User Auth Token for the target channel id, with the scope bits:read channelId String Target Channel Id Optional Parameters\nNone\nCode-Snippets Subscribe to all cheers to user twitch4j and register a listener that prints all messages to console\ntwitchClient.getPubSub().listenForCheerEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getEventManager().onEvent(ChannelBitsEvent.class, System.out::println); twitchClient.pubSub.listenForCheerEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(ChannelBitsEvent, System.out::println) twitchClient.pubSub.listenForCheerEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(ChannelBitsEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Bits Events","url":"/docs/pubsub/topic-bits-events/"},{"content":"Topic - Channel Points Events Description This topic can be used to monitor a channel\u0026rsquo;s community points events. The only officially documented subtype of this event is for a custom reward being redeemed, but this library also includes other subtypes.\nMethod Definition Required Parameters\nName Type Description credential OAuth2Credential User Auth Token for the target channel id, with the scope channel:read:redemptions channelId String Target Channel Id Optional Parameters\nNone\nCode-Snippets Subscribe to the topic for a given channel twitchClient.getPubSub().listenForChannelPointsRedemptionEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.pubSub.listenForChannelPointsRedemptionEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.pubSub.listenForChannelPointsRedemptionEvents(credential, \u0026#34;149223493\u0026#34;) Listen for Custom Reward Redemptions Fired when a custom reward is redeemed in the channel.\ntwitchClient.getEventManager().onEvent(RewardRedeemedEvent.class, System.out::println); twitchClient.eventManager.onEvent(RewardRedeemedEvent, System.out::println) twitchClient.eventManager.onEvent(RewardRedeemedEvent::class.java, System.out::println) Listen for Redemption Status Updates Not documented by Twitch.\nFired when the status of a redemption changes (e.g. completed or rejected).\nNote that, at the time of writing, the status is ACTION_TAKEN whether the reward was completed or rejected, rather than FULFILLED or UNFULFILLED.\ntwitchClient.getEventManager().onEvent(RedemptionStatusUpdateEvent.class, System.out::println); twitchClient.eventManager.onEvent(RedemptionStatusUpdateEvent, System.out::println) twitchClient.eventManager.onEvent(RedemptionStatusUpdateEvent::class.java, System.out::println) Listen for Reward Creations Not documented by Twitch.\nFired when a custom reward is created.\ntwitchClient.getEventManager().onEvent(CustomRewardCreatedEvent.class, System.out::println); twitchClient.eventManager.onEvent(CustomRewardCreatedEvent, System.out::println) twitchClient.eventManager.onEvent(CustomRewardCreatedEvent::class.java, System.out::println) Listen for Reward Updates Not documented by Twitch.\nFired when a custom reward is updated.\ntwitchClient.getEventManager().onEvent(CustomRewardUpdatedEvent.class, System.out::println); twitchClient.eventManager.onEvent(CustomRewardUpdatedEvent, System.out::println) twitchClient.eventManager.onEvent(CustomRewardUpdatedEvent::class.java, System.out::println) Listen for Reward Deletions Not documented by Twitch.\nFired when custom reward is deleted.\ntwitchClient.getEventManager().onEvent(CustomRewardDeletedEvent.class, System.out::println); twitchClient.eventManager.onEvent(CustomRewardDeletedEvent, System.out::println) twitchClient.eventManager.onEvent(CustomRewardDeletedEvent::class.java, System.out::println) Listen for Update Redemption Status Progress Not documented by Twitch.\nFired when there is an update to the redemption progress.\ntwitchClient.getEventManager().onEvent(UpdateRedemptionProgressEvent.class, System.out::println); twitchClient.eventManager.onEvent(UpdateRedemptionProgressEvent, System.out::println) twitchClient.eventManager.onEvent(UpdateRedemptionProgressEvent::class.java, System.out::println) Listen for Update Redemption Status Completion Not documented by Twitch.\nFired when the redemption progress has completed.\ntwitchClient.getEventManager().onEvent(UpdateRedemptionFinishedEvent.class, System.out::println); twitchClient.eventManager.onEvent(UpdateRedemptionFinishedEvent, System.out::println) twitchClient.eventManager.onEvent(UpdateRedemptionFinishedEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Channel Points Events","url":"/docs/pubsub/topic-channel-points-events/"},{"content":"Topic - Commerce Events Description This topic is deprecated by Twitch, but it could be used to monitor purchases in a specified channel.\nMethod Definition Required Parameters\nName Type Description credential OAuth2Credential User Auth Token for the target channel id, with any scope channelId String Target Channel Id Optional Parameters\nNone\nCode-Snippets Subscribe to all commerce purchases in the twitch4j channel and register a listener that prints all messages to console\ntwitchClient.getPubSub().listenForCommerceEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getEventManager().onEvent(ChannelCommerceEvent.class, System.out::println); twitchClient.pubSub.listenForCommerceEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.eventManager.onEvent(ChannelCommerceEvent, System.out::println) twitchClient.pubSub.listenForCommerceEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.eventManager.onEvent(ChannelCommerceEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Commerce Events","url":"/docs/pubsub/topic-commerce-events/"},{"content":"Topic - Following Events Description This topic can be used to monitor whenever a specified channel receives followers.\nIn terms of documented replacements, the User Follows Webhook provides another real-time system to receive these events. If a webhook server cannot be used, one can also query API Helix \u0026gt; Users Followers at a regular interval to determine new followers. In fact, Twitch4J \u0026gt; Client Helper can do this for you.\nWith all undocumented topics, use at your own risk.\nMethod Definition Name Type Description credential OAuth2Credential Auth Token (may not necessarily be required) channelId String Target Channel Id Code-Snippets Subscribe to new follower events for user twitch4j and register a listener that prints all messages to console\ntwitchClient.getPubSub().listenForFollowingEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getEventManager().onEvent(FollowingEvent.class, System.out::println); twitchClient.pubSub.listenForFollowingEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.eventManager.onEvent(FollowingEvent, System.out::println) twitchClient.pubSub.listenForFollowingEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.eventManager.onEvent(FollowingEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Following Events","url":"/docs/pubsub/topic-following-events/"},{"content":"Topic - Friendship Events Description This topic can be used to monitor changes to the friendship state of a specified user with others.\nPossible friendship changes include:\nRequested Rejected Accepted Removed and self variants (i.e. when this account itself is responsible for the change rather than the other entity) With all undocumented topics, use at your own risk.\nMethod Definition Name Type Description credential OAuth2Credential User Auth Token for the target user id, with the scope user_friends_read userId String Target User Id Code-Snippets Subscribe to friendship events for user twitch4j and register a listener that prints all messages to console\ntwitchClient.getPubSub().listenForFriendshipEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getEventManager().onEvent(FriendshipEvent.class, System.out::println); twitchClient.pubSub.listenForFriendshipEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.eventManager.onEvent(FriendshipEvent, System.out::println) twitchClient.pubSub.listenForFriendshipEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.eventManager.onEvent(FriendshipEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Friendship Events","url":"/docs/pubsub/topic-friendship-events/"},{"content":"Topic - Hype Train Events Description This topic can be used to monitor hype train events for a specified channel.\nWith all undocumented topics, use at your own risk.\nMethod Definition Name Type Description credential OAuth2Credential Auth Token (may not necessarily be required) channelId String Target Channel Id Code-Snippets Subscribe to the topic for a given channel twitchClient.getPubSub().listenForHypeTrainEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.pubSub.listenForHypeTrainEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.pubSub.listenForHypeTrainEvents(credential, \u0026#34;149223493\u0026#34;) Listen for Hype Train Starts twitchClient.getEventManager().onEvent(HypeTrainStartEvent.class, System.out::println); twitchClient.eventManager.onEvent(HypeTrainStartEvent, System.out::println) twitchClient.eventManager.onEvent(HypeTrainStartEvent::class.java, System.out::println) Listen for Hype Train Progression twitchClient.getEventManager().onEvent(HypeTrainProgressionEvent.class, System.out::println); twitchClient.eventManager.onEvent(HypeTrainProgressionEvent, System.out::println) twitchClient.eventManager.onEvent(HypeTrainProgressionEvent::class.java, System.out::println) Listen for Hype Train Level Ups twitchClient.getEventManager().onEvent(HypeTrainLevelUpEvent.class, System.out::println); twitchClient.eventManager.onEvent(HypeTrainLevelUpEvent, System.out::println) twitchClient.eventManager.onEvent(HypeTrainLevelUpEvent::class.java, System.out::println) Listen for Hype Train Ends twitchClient.getEventManager().onEvent(HypeTrainEndEvent.class, System.out::println); twitchClient.eventManager.onEvent(HypeTrainEndEvent, System.out::println) twitchClient.eventManager.onEvent(HypeTrainEndEvent::class.java, System.out::println) Listen for Conductor Updates twitchClient.getEventManager().onEvent(HypeTrainConductorUpdateEvent.class, System.out::println); twitchClient.eventManager.onEvent(HypeTrainConductorUpdateEvent, System.out::println) twitchClient.eventManager.onEvent(HypeTrainConductorUpdateEvent::class.java, System.out::println) Listen for Cooldown Expiration twitchClient.getEventManager().onEvent(HypeTrainCooldownExpirationEvent.class, System.out::println); twitchClient.eventManager.onEvent(HypeTrainCooldownExpirationEvent, System.out::println) twitchClient.eventManager.onEvent(HypeTrainCooldownExpirationEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Hype Train Events","url":"/docs/pubsub/topic-hype-train-events/"},{"content":"Topic - Hype Train Rewards Description This topic can be used to monitor the distribution of rewards associated with hype trains for a given channel.\nWith all undocumented topics, use at your own risk.\nMethod Definition Name Type Description credential OAuth2Credential User Auth Token (may not necessarily be required) channelId String Target Channel Id Code-Snippets Subscribe to hype train rewards for channel twitch4j and register a listener that prints all messages to console\ntwitchClient.getPubSub().listenForHypeTrainRewardEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getEventManager().onEvent(HypeTrainRewardsEvent.class, System.out::println); twitchClient.pubSub.listenForHypeTrainRewardEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(HypeTrainRewardsEvent, System.out::println) twitchClient.pubSub.listenForHypeTrainRewardEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(HypeTrainRewardsEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Hype Train Rewards","url":"/docs/pubsub/topic-hype-train-rewards/"},{"content":"Topic - Leaderboard Events Description This topic can be used to monitor weekly/monthly leaderboard events of a specified channel in terms of bits used and subs gifted.\nWith all undocumented topics, use at your own risk.\nMethod Definition Name Type Description credential OAuth2Credential Auth Token (may not necessarily be required) channelId String Target Channel Id Code-Snippets Subscribe: Weekly Leaderboard Events // One can subscribe to one or both of these: twitchClient.getPubSub().listenForChannelBitsLeaderboardEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getPubSub().listenForChannelSubLeaderboardEvents(credential, \u0026#34;149223493\u0026#34;); // Alternatively, this helper method can be used to subscribe to the above two topics in one line: twitchClient.getPubSub().listenForLeaderboardEvents(credential, \u0026#34;149223493\u0026#34;); // One can subscribe to one or both of these: twitchClient.pubSub.listenForChannelBitsLeaderboardEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.pubSub.listenForChannelSubLeaderboardEvents(credential, \u0026#34;149223493\u0026#34;); // Alternatively, this helper method can be used to subscribe to the above two topics in one line: twitchClient.pubSub.listenForLeaderboardEvents(credential, \u0026#34;149223493\u0026#34;); // One can subscribe to one or both of these: twitchClient.pubSub.listenForChannelBitsLeaderboardEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.pubSub.listenForChannelSubLeaderboardEvents(credential, \u0026#34;149223493\u0026#34;); // Alternatively, this helper method can be used to subscribe to the above two topics in one line: twitchClient.pubSub.listenForLeaderboardEvents(credential, \u0026#34;149223493\u0026#34;); Subscribe: Monthly Leaderboard Events // One can subscribe to one or both of these: twitchClient.getPubSub().listenForChannelBitsLeaderboardMonthlyEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getPubSub().listenForChannelSubLeaderboardMonthlyEvents(credential, \u0026#34;149223493\u0026#34;); // Alternatively, this helper method can be used to subscribe to the above two topics in one line: twitchClient.getPubSub().listenForLeaderboardMonthlyEvents(credential, \u0026#34;149223493\u0026#34;); // One can subscribe to one or both of these: twitchClient.pubSub.listenForChannelBitsLeaderboardMonthlyEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.pubSub.listenForChannelSubLeaderboardMonthlyEvents(credential, \u0026#34;149223493\u0026#34;); // Alternatively, this helper method can be used to subscribe to the above two topics in one line: twitchClient.pubSub.listenForLeaderboardMonthlyEvents(credential, \u0026#34;149223493\u0026#34;); // One can subscribe to one or both of these: twitchClient.pubSub.listenForChannelBitsLeaderboardMonthlyEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.pubSub.listenForChannelSubLeaderboardMonthlyEvents(credential, \u0026#34;149223493\u0026#34;); // Alternatively, this helper method can be used to subscribe to the above two topics in one line: twitchClient.pubSub.listenForLeaderboardMonthlyEvents(credential, \u0026#34;149223493\u0026#34;); Listen: Bits Leaderboard Update twitchClient.getEventManager().onEvent(BitsLeaderboardEvent.class, System.out::println); twitchClient.eventManager.onEvent(BitsLeaderboardEvent, System.out::println) twitchClient.eventManager.onEvent(BitsLeaderboardEvent::class.java, System.out::println) Listen: Sub Gifts Leaderboard Update twitchClient.getEventManager().onEvent(SubLeaderboardEvent.class, System.out::println); twitchClient.eventManager.onEvent(SubLeaderboardEvent, System.out::println) twitchClient.eventManager.onEvent(SubLeaderboardEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Leaderboard Events","url":"/docs/pubsub/topic-leaderboard-events/"},{"content":"Topic - Moderation Events Description This topic can be used to monitor whenever a moderation performs an action in the specified channel.\nMethod Definition Required Parameters\nName Type Description credential OAuth2Credential User Auth Token for the target user id, with the scope channel:moderate channelId String Target Channel Id Optional Parameters\nNone\nCode-Snippets Example: User hexafice subscribes to moderation events in channel twitch4j\n// Listen to topic String userId = \u0026#34;142621956\u0026#34;; // user id of hexafice String broadcasterId = \u0026#34;149223493\u0026#34;; // channel id of twitch4j twitchClient.getPubSub().listenForModerationEvents(credential, broadcasterId, userId); // Handle events twitchClient.getEventManager().onEvent(ChatModerationEvent.class, System.out::println); // Listen to topic String userId = \u0026#34;142621956\u0026#34; // user id of hexafice String broadcasterId = \u0026#34;149223493\u0026#34; // channel id of twitch4j twitchClient.pubSub.listenForModerationEvents(credential, broadcasterId, userId) // Handle events twitchClient.eventManager.onEvent(ChatModerationEvent, System.out::println) // Listen to topic val userId = \u0026#34;142621956\u0026#34; // user id of hexafice val broadcasterId = \u0026#34;149223493\u0026#34; // channel id of twitch4j twitchClient.pubSub.listenForModerationEvents(credential, broadcasterId, userId) // Handle events twitchClient.eventManager.onEvent(ChatModerationEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Moderation Events","url":"/docs/pubsub/topic-moderation-events/"},{"content":"Topic - Onsite Notifications Description This topic can be used to monitor notifications that would occur on the twitch website (e.g. if a stream goes live).\nWith all undocumented topics, use at your own risk.\nMethod Definition Name Type Description credential OAuth2Credential User Auth Token for the target user id userId String Target User Id Code-Snippets Example: General use Subscribe to all onsite notifications for user twitch4j and register listeners that print all messages to console\n// Subscribe to the topic twitchClient.getPubSub().listenForOnsiteNotificationEvents(credential, \u0026#34;149223493\u0026#34;); // Listen to notification creations twitchClient.getEventManager().onEvent(OnsiteNotificationCreationEvent.class, System.out::println); // Listen for notification summary updates twitchClient.getEventManager().onEvent(UpdateOnsiteNotificationSummaryEvent.class, System.out::println); // Subscribe to the topic twitchClient.pubSub.listenForOnsiteNotificationEvents(credential, \u0026#34;149223493\u0026#34;); // Listen to notification creations twitchClient.eventManager.onEvent(OnsiteNotificationCreationEvent, System.out::println); // Listen for notification summary updates twitchClient.eventManager.onEvent(UpdateOnsiteNotificationSummaryEvent, System.out::println); // Subscribe to the topic twitchClient.pubSub.listenForOnsiteNotificationEvents(credential, \u0026#34;149223493\u0026#34;); // Listen to notification creations twitchClient.eventManager.onEvent(OnsiteNotificationCreationEvent::class.java, System.out::println); // Listen for notification summary updates twitchClient.eventManager.onEvent(UpdateOnsiteNotificationSummaryEvent::class.java, System.out::println); Example: Live status monitoring Note: a single channel can be following up to 2000 channels, as of the time of writing. Such events cannot be fired unless the notifications bell is enabled for the channel.\nNote: these notifications tend to be fired faster than repeatedly querying API - Helix \u0026gt; Streams Get, as TwitchClientHelper (Twitch4J \u0026gt; Client Helper) does.\nDisclaimer: Do not solely rely upon this code; fallback mechanisms should be employed as well. // Establish which channels\u0026#39; live state is relevant Set\u0026lt;String\u0026gt; interestedChannelIds = new HashSet\u0026lt;\u0026gt;(); interestedChannelIds.add(\u0026#34;12826\u0026#34;); interestedChannelIds.add(\u0026#34;53888434\u0026#34;); interestedChannelIds.add(\u0026#34;141981764\u0026#34;); interestedChannelIds.add(\u0026#34;142621956\u0026#34;); // Subscribe to the topic twitchClient.getPubSub().listenForOnsiteNotificationEvents(credential, userId); // Listen to notification creations twitchClient.getEventManager().onEvent(OnsiteNotificationCreationEvent.class, e -\u0026gt; { OnsiteNotification notification = e.getData().getNotification(); if (notification.getType().equalsIgnoreCase(\u0026#34;streamup\u0026#34;)) { List\u0026lt;OnsiteNotification.Creator\u0026gt; creators = notification.getCreators(); if (creators != null \u0026amp;\u0026amp; creators.size() == 1 \u0026amp;\u0026amp; interestedChannelIds.contains(creators.get(0).getUserId())) { System.out.println(e); // Handle Go Live } } }); // Establish which channels\u0026#39; live state is relevant def interestedChannelIds = new HashSet\u0026lt;\u0026gt;() interestedChannelIds.add(\u0026#34;12826\u0026#34;) interestedChannelIds.add(\u0026#34;53888434\u0026#34;) interestedChannelIds.add(\u0026#34;141981764\u0026#34;) interestedChannelIds.add(\u0026#34;142621956\u0026#34;) // Subscribe to the topic twitchClient.pubSub.listenForOnsiteNotificationEvents(credential, userId) // Listen to notification creations twitchClient.eventManager.onEvent(OnsiteNotificationCreationEvent) { e -\u0026gt; def notification = e.data.notification if (notification.type.equalsIgnoreCase(\u0026#34;streamup\u0026#34;)) { def creators = notification.creators if (creators != null \u0026amp;\u0026amp; creators.size() == 1 \u0026amp;\u0026amp; interestedChannelIds.contains(creators[0].userId)) { System.out.println(e) // Handle Go Live } } } // Establish which channels\u0026#39; live state is relevant val interestedChannelIds = setOf(\u0026#34;12826\u0026#34;, \u0026#34;53888434\u0026#34;, \u0026#34;141981764\u0026#34;, \u0026#34;142621956\u0026#34;) // Subscribe to the topic twitchClient.pubSub.listenForOnsiteNotificationEvents(credential, userId); // Listen to notification creations twitchClient.eventManager.onEvent(OnsiteNotificationCreationEvent::class.java) { e -\u0026gt; val notification = e.`data`.notification; if (notification.type.equals(\u0026#34;streamup\u0026#34;, true)) { notification.creators?.apply { if (size == 1 \u0026amp;\u0026amp; interestedChannelIds.contains(get(0).userId) { println(e); // Handle Go Live } } } } ","tags":null,"title":"Topic - Onsite Notifications","url":"/docs/pubsub/topic-onsite-notifications/"},{"content":"Topic - Poll Events Description This topic can be used to monitor poll events in a specified channel.\nSub-types include:\nPoll creation Poll update (e.g. new vote or bits usage or channel points towards a specific choice) Poll completion Poll termination Poll archived With all undocumented topics, use at your own risk.\nMethod Definition Name Type Description credential OAuth2Credential Auth Token (may not necessarily be required) channelId String Target Channel Id Code-Snippets Subscribe to all poll events in channel twitch4j and register a listener that prints all messages to console\ntwitchClient.getPubSub().listenForPollEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getEventManager().onEvent(PollsEvent.class, System.out::println); twitchClient.pubSub.listenForPollEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(PollsEvent, System.out::println) twitchClient.pubSub.listenForPollEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(PollsEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Poll Events","url":"/docs/pubsub/topic-poll-events/"},{"content":"Topic - Presence Events Description This topic can be used to monitor the presence of a specified user\u0026rsquo;s friends (and oneself, to an extent).\nExample availabilities include:\nbusy idle offline online Example activities include:\nnone watching broadcasting With all undocumented topics, use at your own risk.\nMethod Definition Name Type Description credential OAuth2Credential User Auth Token for the target user id, with the scope user_presence_friends_read and/or user_presence_edit userId String Target User Id Code-Snippets Example: General use Subscribe to presence events for user twitch4j and register a listener that prints all messages to console\ntwitchClient.getPubSub().listenForPresenceEvents(credential, \u0026#34;149223493\u0026#34;); // Listen for presence updates twitchClient.getEventManager().onEvent(UserPresenceEvent.class, System.out::println); // Listen for updates to the user\u0026#39;s presence settings twitchClient.getEventManager().onEvent(PresenceSettingsEvent.class, System.out::println); twitchClient.pubSub.listenForPresenceEvents(credential, \u0026#34;149223493\u0026#34;) // Listen for presence updates twitchClient.eventManager.onEvent(UserPresenceEvent, System.out::println) // Listen for updates to the user\u0026#39;s presence settings twitchClient.eventManager.onEvent(PresenceSettingsEvent, System.out::println) twitchClient.pubSub.listenForPresenceEvents(credential, \u0026#34;149223493\u0026#34;) // Listen for presence updates twitchClient.eventManager.onEvent(UserPresenceEvent::class.java, System.out::println) // Listen for updates to the user\u0026#39;s presence settings twitchClient.eventManager.onEvent(PresenceSettingsEvent::class.java, System.out::println) Example: Live status monitoring Note: a single account can befriend 500 users on Twitch (which is necessary for such presence events to occur), at the time of writing.\nNote: these events tend to be fired significantly faster than the documented analogs in the Helix API.\nDisclaimer: do not solely rely upon this code; fallback mechanisms should be employed as well.\ntwitchClient.getEventManager().onEvent(UserPresenceEvent.class, e -\u0026gt; { boolean wentLive = e.getData().getActivities().stream().anyMatch(a -\u0026gt; a.getType().equalsIgnoreCase(\u0026#34;broadcasting\u0026#34;)); if (wentLive) { System.out.println(e); // Handle Go Live } }); twitchClient.eventManager.onEvent(UserPresenceEvent) { e -\u0026gt; boolean wentLive = e.data.activities.any { it.type.equalsIgnoreCase(\u0026#34;broadcasting\u0026#34;) } if (wentLive) { System.out.println(e); // Handle Go Live } } twitchClient.eventManager.onEvent(UserPresenceEvent::class.java) { e -\u0026gt; val wentLive = e.`data`.activities.any { it.type.equalsIgnoreCase(\u0026#34;broadcasting\u0026#34;) } if (wentLive) { println(e); // Handle Go Live } } ","tags":null,"title":"Topic - Presence Events","url":"/docs/pubsub/topic-presence-events/"},{"content":"Topic - Public Cheer Events Description This topic can be used to monitor public cheer events for a specified channel. Currently, this only represents Cheerbombs (i.e. a cheer with shared rewards associated).\nWith all undocumented topics, use at your own risk.\nMethod Definition Name Type Description credential OAuth2Credential Auth Token (may not necessarily be required) channelId String Target Channel Id Code-Snippets Subscribe to all cheerbombs in channel twitch4j and register a listener that prints all messages to console\ntwitchClient.getPubSub().listenForPublicCheerEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getEventManager().onEvent(CheerbombEvent.class, System.out::println); twitchClient.pubSub.listenForPublicCheerEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(CheerbombEvent, System.out::println) twitchClient.pubSub.listenForPublicCheerEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(CheerbombEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Public Cheer Events","url":"/docs/pubsub/topic-public-cheer-events/"},{"content":"Topic - Raid Events Description This topic can be used to monitor raid events for a specified channel. This does not refer to the specified channel getting raided, only actions taken by the channel itself (or its editors).\nWith all undocumented topics, use at your own risk.\nMethod Definition Name Type Description credential OAuth2Credential Auth Token (may not necessarily be required) channelId String Target Channel Id Code-Snippets Subscribe to all raid events in channel twitch4j and register a listener that prints all messages to console\n// Subscribe to the topic twitchClient.getPubSub().listenForRaidEvents(credential, \u0026#34;149223493\u0026#34;); // Listen for the channel executing a raid twitchClient.getEventManager().onEvent(RaidGoEvent.class, System.out::println); // Listen for raid progress (counting down until the raid can go through) twitchClient.getEventManager()onEvent(RaidUpdateEvent.class, System.out::println); // Listen for raid cancellations twitchClient.getEventManager().onEvent(RaidCancelEvent.class, System.out::println); // Subscribe to the topic twitchClient.pubSub.listenForRaidEvents(credential, \u0026#34;149223493\u0026#34;) // Listen for the channel executing a raid twitchClient.eventManager.onEvent(RaidGoEvent, System.out::println) // Listen for raid progress (counting down until the raid can go through) twitchClient.eventManageronEvent(RaidUpdateEvent, System.out::println) // Listen for raid cancellations twitchClient.eventManager.onEvent(RaidCancelEvent, System.out::println) // Subscribe to the topic twitchClient.pubSub.listenForRaidEvents(credential, \u0026#34;149223493\u0026#34;) // Listen for the channel executing a raid twitchClient.eventManager.onEvent(RaidGoEvent::class.java, System.out::println) // Listen for raid progress (counting down until the raid can go through) twitchClient.eventManageronEvent(RaidUpdateEvent::class.java, System.out::println) // Listen for raid cancellations twitchClient.eventManager.onEvent(RaidCancelEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Raid Events","url":"/docs/pubsub/topic-raid-events/"},{"content":"Topic - Sub Gift Events Description This topic can be used to monitor sub gift activity in a specified channel.\nUnlike the documented Channel Subscriptions topic (fires many events upon a multi-target gift), this allows one to know how many subs were gifted in a single event. The documented analog to this topic is in the TwitchChat module.\nWith all undocumented topics, use at your own risk.\nMethod Definition Name Type Description credential OAuth2Credential Auth Token (may not necessarily be required) channelId String Target Channel Id Code-Snippets Subscribe to all sub gift events in channel twitch4j and register a listener that prints all messages to console\ntwitchClient.getPubSub().listenForChannelSubGiftsEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getEventManager().onEvent(ChannelSubGiftEvent.class, System.out::println); twitchClient.pubSub.listenForChannelSubGiftsEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(ChannelSubGiftEvent, System.out::println) twitchClient.pubSub.listenForChannelSubGiftsEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(ChannelSubGiftEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Sub Gift Events","url":"/docs/pubsub/topic-sub-gift-events/"},{"content":"Topic - Subscribe Events Description This topic can be used to monitor whenever a specified channel receives a new subscription.\nMethod Definition Required Parameters\nName Type Description credential OAuth2Credential User Auth Token for the target channel id, with the scope channel_subscriptions channelId String Target Channel Id Optional Parameters\nNone\nCode-Snippets Subscribe to all subscription events to the twitch4j channel and register a listener that prints all messages to console\ntwitchClient.getPubSub().listenForSubscriptionEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getEventManager().onEvent(ChannelSubscribeEvent.class, System.out::println); twitchClient.pubSub.listenForSubscriptionEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(ChannelSubscribeEvent, System.out::println) twitchClient.pubSub.listenForSubscriptionEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(ChannelSubscribeEvent::class.java, System.out::println) ","tags":null,"title":"Topic - Subscribe Events","url":"/docs/pubsub/topic-subscribe-events/"},{"content":"Topic - User Community Points Events Description This topic can be used to monitor events regarding a specified user\u0026rsquo;s community points.\nThe topic is analogous to the documented PubSub \u0026gt; Channel Points Events, but from the perspective of the user (who may be in multiple channels).\nWith all undocumented topics, use at your own risk.\nMethod Definition Name Type Description credential OAuth2Credential User Auth Token for the target user id (scope undocumented) userId String Target User Id Code-Snippets Subscribe to all user community points events for twitch4j and register a listener that prints all messages to console\n// Subscribe to topic twitchClient.getPubSub().listenForUserChannelPointsEvents(credential, \u0026#34;149223493\u0026#34;); // Register event listeners twitchClient.getEventManager().onEvent(PointsEarnedEvent.class, System.out::println); twitchClient.getEventManager().onEvent(ClaimAvailableEvent.class, System.out::println); twitchClient.getEventManager().onEvent(ClaimClaimedEvent.class, System.out::println); twitchClient.getEventManager().onEvent(PointsSpentEvent.class, System.out::println); twitchClient.getEventManager().onEvent(RewardRedeemedEvent.class, System.out::println); // Subscribe to topic twitchClient.pubSub.listenForUserChannelPointsEvents(credential, \u0026#34;149223493\u0026#34;); // Register event listeners twitchClient.eventManager.onEvent(PointsEarnedEvent, System.out::println); twitchClient.eventManager.onEvent(ClaimAvailableEvent, System.out::println); twitchClient.eventManager.onEvent(ClaimClaimedEvent, System.out::println); twitchClient.eventManager.onEvent(PointsSpentEvent, System.out::println); twitchClient.eventManager.onEvent(RewardRedeemedEvent, System.out::println); // Subscribe to topic twitchClient.pubSub.listenForUserChannelPointsEvents(credential, \u0026#34;149223493\u0026#34;); // Register event listeners twitchClient.eventManager.onEvent(PointsEarnedEvent::class.java, System.out::println); twitchClient.eventManager.onEvent(ClaimAvailableEvent::class.java, System.out::println); twitchClient.eventManager.onEvent(ClaimClaimedEvent::class.java, System.out::println); twitchClient.eventManager.onEvent(PointsSpentEvent::class.java, System.out::println); twitchClient.eventManager.onEvent(RewardRedeemedEvent::class.java, System.out::println); ","tags":null,"title":"Topic - User Community Points Events","url":"/docs/pubsub/topic-user-community-points-events/"},{"content":"Topic - Video Playback Events Description This topic can be used to monitor video playback events for a specified channel.\nSubtypes include:\nCommercial started Stream went down Stream went up View count update Note: The stream up/down events tend to be fired significantly faster than what is reported by Helix. Note: the view count reported by this topic is more reflective of the value on the website than API - TMI \u0026gt; Get Viewers\nWith all undocumented topics, use at your own risk.\nMethod Definition By Channel ID (Preferred) Name Type Description credential OAuth2Credential Auth Token (may not necessarily be required) channelId String Target Channel Id By Channel Name (Alternative) Name Type Description credential OAuth2Credential Auth Token (may not necessarily be required) channelName String Target Channel Name Code-Snippets Subscribe to topic By Channel ID Preferred way to subscribe to the topic; used by first-party clients and more resistant to name weirdness.\ntwitchClient.getPubSub().listenForVideoPlaybackEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.pubSub.listenForVideoPlaybackEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.pubSub.listenForVideoPlaybackEvents(credential, \u0026#34;149223493\u0026#34;) By Channel Name An alternative means to subscribe to the topic, if one does not have the channel ID and does not wish to query it.\ntwitchClient.getPubSub().listenForVideoPlaybackByNameEvents(credential, \u0026#34;twitch4j\u0026#34;); twitchClient.pubSub.listenForVideoPlaybackByNameEvents(credential, \u0026#34;twitch4j\u0026#34;) twitchClient.pubSub.listenForVideoPlaybackByNameEvents(credential, \u0026#34;twitch4j\u0026#34;) Listen for Events // Handle all subtypes twitchClient.getEventManager().onEvent(VideoPlaybackEvent.class, System.out::println); // Alternatively, only consider a specific subtype twitchClient.getEventManager().onEvent(VideoPlaybackEvent.class, e -\u0026gt; { if (e.getData().getType() == VideoPlaybackData.Type.STREAM_UP) { System.out.println(e); // Handle Go Live } }); // Handle all subtypes twitchClient.eventManager.onEvent(VideoPlaybackEvent, System.out::println) // Alternatively, only consider a specific subtype twitchClient.eventManager.onEvent(VideoPlaybackEvent) { e -\u0026gt; if (e.data.type == VideoPlaybackData.Type.STREAM_UP) { System.out.println(e); // Handle Go Live } } // Handle all subtypes twitchClient.eventManager.onEvent(VideoPlaybackEvent::class.java, System.out::println) // Alternatively, only consider a specific subtype twitchClient.eventManager.onEvent(VideoPlaybackEvent::class.java) { e -\u0026gt; if (e.data.type == VideoPlaybackData.Type.STREAM_UP) { println(e); // Handle Go Live } } ","tags":null,"title":"Topic - Video Playback Events","url":"/docs/pubsub/topic-video-playback-events/"},{"content":"Topic - Whispers Description This topic can be used to monitor whenever a specified user receives a whisper.\nNote that this can cause duplication of PrivateMessageEvent if one is also using TwitchChat to monitor whispers.\nMethod Definition Required Parameters\nName Type Description credential OAuth2Credential User Auth Token for the target user id, with the scope whispers:read userId String Target User Id Optional Parameters\nNone\nCode-Snippets Subscribe to all whispers to user twitch4j and register a listener that prints all messages to console\ntwitchClient.getPubSub().listenForWhisperEvents(credential, \u0026#34;149223493\u0026#34;); twitchClient.getEventManager().onEvent(PrivateMessageEvent.class, System.out::println); twitchClient.pubSub.listenForWhisperEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(PrivateMessageEvent, System.out::println) twitchClient.pubSub.listenForWhisperEvents(credential, \u0026#34;149223493\u0026#34;) twitchClient.eventManager.onEvent(PrivateMessageEvent, System.out::println) ","tags":null,"title":"Topic - Whispers","url":"/docs/pubsub/topic-whispers/"},{"content":"Follow Channel Description Adds a specified user to the followers of a specified channel.\nThere is an error response (422 Unprocessable Entity) if the channel could not be followed.\nMethod Definition @RequestLine(\u0026#34;PUT /users/{user}/follows/channels/{targetUser}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;Object\u0026gt; addFollow( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;user\u0026#34;) Long userId, @Param(\u0026#34;targetUser\u0026#34;) Long targetUserId ); Required Parameters\nNone\nOptional Parameters\nNone\nCode-Snippets follow a channel twitchClient.getKraken().addFollow(auth, user, targetUserId).execute(); twitchClient.kraken.addFollow(auth, user, targetUserId).execute() twitchClient.kraken.addFollow(auth, user, targetUserId).execute() ","tags":null,"title":"Users - Add Follow","url":"/docs/rest-kraken/user-add-follow/"},{"content":"Get Stream Key Description Gets the channel stream key for a user.\nMethod Definition @RequestLine(\u0026#34;GET /streams/key?broadcaster_id={broadcaster_id}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;StreamKeyList\u0026gt; getStreamKey( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;broadcaster_id\u0026#34;) String broadcasterId ); Required Parameters\nName Type Description authToken string User Access Token (scope: channel:read:stream_key) broadcasterId string User ID of the broadcaster Optional Parameters\nNone\nCode-Snippets print stream key StreamKeyList resultList = twitchClient.getHelix().getStreamKey(authToken, broadcasterId).execute(); resultList.getKeys().forEach(key -\u0026gt; { System.out.println(key); }); def resultList = twitchClient.helix.getStreamKey(authToken, broadcasterId).execute() resultList.keys.each { key -\u0026gt; System.out.println key } val resultList = twitchClient.helix.getStreamKey(authToken, broadcasterId).execute() resultList.keys.forEach { key -\u0026gt; println(key) } ","tags":null,"title":"Streams - Get Key","url":"/docs/rest-helix/streams-get-key/"},{"content":"Get Stream Markers Description Gets a list of markers for either a specified user’s most recent stream or a specified VOD/video (stream), ordered by recency. A marker is an arbitrary point in a stream that the broadcaster wants to mark; e.g., to easily return to later. The only markers returned are those created by the user identified by the Bearer token.\nThe response has a JSON payload with a data field containing an array of marker information elements and a pagination field containing information required to query for more follow information.\nMethod Definition @RequestLine(\u0026#34;GET /streams/markers?after={after}\u0026amp;before={before}\u0026amp;first={first}\u0026amp;user_id={user_id}\u0026amp;video_id={video_id}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;StreamMarkersList\u0026gt; getStreamMarkers( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;after\u0026#34;) String after, @Param(\u0026#34;before\u0026#34;) String before, @Param(\u0026#34;first\u0026#34;) Integer limit, @Param(\u0026#34;user_id\u0026#34;) Long userId, @Param(\u0026#34;video_id\u0026#34;) Long videoId ); Required Parameters (one of)\nName Type Description authToken string User Auth Token -\u0026gt; user:read:broadcast user_id string ID of the broadcaster from whose stream markers are returned. video_id string ID of the VOD/video whose stream markers are returned. Optional Parameters\nName Type Description after string Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. before string Cursor for backward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. limit string Maximum number of objects to return. Maximum: 100. Default: 20. Code-Snippets print markers // TestCase StreamMarkersList resultList = twitchClient.getHelix().getStreamMarkers(authToken, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, null, \u0026#34;217359661l\u0026#34;, \u0026#34;137512364l\u0026#34;).execute(); resultList.getStreamMarkers().forEach(stream -\u0026gt; { stream.getVideos().forEach(videoMarker -\u0026gt; { videoMarker.getMarkers().forEach(marker -\u0026gt; { System.out.println(marker.getId() + \u0026#34;:\u0026#34; + marker.getDescription()); }); }); }); // TestCase def resultList = twitchClient.helix.getStreamMarkers(authToken, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, null, \u0026#34;217359661l\u0026#34;, \u0026#34;137512364l\u0026#34;).execute() resultList.streamMarkers.each { stream -\u0026gt; stream.videos.each { videoMarker -\u0026gt; videoMarker.markers.each { marker -\u0026gt; System.out.println \u0026#34;${marker.id}:${marker.description}\u0026#34; } } } val resultList = twitchClient.helix.getStreamMarkers(authToken, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, null, \u0026#34;217359661l\u0026#34;, \u0026#34;137512364l\u0026#34;).execute() resultList.streamMarkers.forEach { stream -\u0026gt; stream.videos.forEach { videoMarker -\u0026gt; videoMarker.markers.forEach { marker -\u0026gt; println(\u0026#34;${marker.id}:${marker.description}\u0026#34;) } } } ","tags":null,"title":"Streams - Get Markers","url":"/docs/rest-helix/streams-markers-get/"},{"content":"Get All Stream Tags Description Gets the list of all stream tags defined by Twitch, optionally filtered by tag ID(s).\nThe response has a JSON payload with a data field containing an array of tag elements and a pagination field containing information required to query for more tags.\nMethod Definition @RequestLine(\u0026#34;GET /tags/streams?after={after}\u0026amp;first={first}\u0026amp;tag_id={tag_id}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;StreamTagList\u0026gt; getAllStreamTags( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;after\u0026#34;) String after, @Param(\u0026#34;first\u0026#34;) Integer limit, @Param(\u0026#34;tag_id\u0026#34;) List\u0026lt;UUID\u0026gt; tagIds ); Required Parameters\nNone\nOptional Parameters\nName Type Description authToken string User Auth Token after string Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. limit string Maximum number of objects to return. Maximum: 100. Default: 20. tagIds string ID of a tag. Multiple IDs can be specified, separated by ampersands. If provided, only the specified tag(s) is(are) returned. Code-Snippets ","tags":null,"title":"StreamTags - Get All Stream Tags","url":"/docs/rest-helix/streamtags-all/"},{"content":"Get StreamTags of Stream Description Gets the list of tags for a specified stream (channel). The response has a JSON payload with a data field containing an array of tag elements.\nMethod Definition @RequestLine(\u0026#34;GET /streams/tags?broadcaster_id={broadcaster_id}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;StreamTagList\u0026gt; getStreamTags( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;broadcaster_id\u0026#34;) Long broadcasterId ); Required Parameters\nName Type Description broadcaster_id string ID of the stream thats tags are going to be fetched Optional Parameters\nName Type Description authToken string User Auth Token Code-Snippets ","tags":null,"title":"StreamTags - Get Stream Tags","url":"/docs/rest-helix/streamtags-stream/"},{"content":"Get all subscribers of a channel Description Get all of a broadcaster’s subscriptions.\nRequired OAuth Scope: channel:read:subscriptions\nMethod Definition @RequestLine(\u0026#34;GET /subscriptions?broadcaster_id={broadcaster_id}\u0026amp;after={after}\u0026amp;before={before}\u0026amp;first={first}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;SubscriptionList\u0026gt; getSubscriptions( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;broadcaster_id\u0026#34;) Long broadcasterId, @Param(\u0026#34;after\u0026#34;) String after, @Param(\u0026#34;before\u0026#34;) String before, @Param(\u0026#34;first\u0026#34;) Integer limit ); Required Parameters\nName Type Description token string bearer token broadcaster_id number ID of the broadcaster. Must match the User ID in the Bearer token Optional Parameters\nName Type Description after string Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. before string Cursor for backward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. limit string Maximum number of objects to return. Maximum: 100. Default: 20. Code-Snippets SubscriptionList resultList = client.getHelix().getSubscriptions(ACCESS_TOKEN, CHANNEL_ID, null, null,null).execute(); resultList.getSubscriptions().forEach(subscription -\u0026gt; { System.out.println(\u0026#34;Subscriber: \u0026#34;+subscription.getUserName()); }); def resultList = client.helix.getSubscriptions(ACCESS_TOKEN, CHANNEL_ID, null, null,null).execute() resultList.subscriptions.forEach { System.out.println(\u0026#34;Subscriber: ${it.userName}\u0026#34;) } val resultList = client.helix.getSubscriptions(ACCESS_TOKEN, CHANNEL_ID, null, null,null).execute() resultList.subscriptions.forEach { println(\u0026#34;Subscriber: ${it.userName}\u0026#34;) } ","tags":null,"title":"Subscriptions - Get all subscribers of a channel","url":"/docs/rest-helix/subscriptions-get/"},{"content":"Replace Stream Tags Description Applies specified tags to a specified stream, overwriting any existing tags applied to that stream. If no tags are specified, all tags previously applied to the stream are removed. Automated tags are not affected by this operation.\nTags expire 72 hours after they are applied, unless the stream is live within that time period. If the stream is live within the 72-hour window, the 72-hour clock restarts when the stream goes offline. The expiration period is subject to change.\nMethod Definition @RequestLine(\u0026#34;PUT /streams/tags?broadcaster_id={broadcaster_id}\u0026#34;) @Headers ({ \u0026#34;Authorization: Bearer {token}\u0026#34;, \u0026#34;Content-Type: application/json\u0026#34; }) @Body(\u0026#34;%7B\\\u0026#34;tag_ids\\\u0026#34;: [{tag_ids}]%7D\u0026#34;) HystrixCommand\u0026lt;Object\u0026gt; replaceStreamTags( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;broadcaster_id\u0026#34;) Long broadcasterId, @Param(value = \u0026#34;tag_ids\u0026#34;, expander = ObjectToJsonExpander.class ) List\u0026lt;UUID\u0026gt; tagIds ); Required Parameters\nName Type Description broadcaster_id string ID of the stream thats tags are going to be fetched Optional Parameters\nName Type Description authToken string User Auth Token tag_ids string IDs of tags to be applied to the stream. Maximum of 100 supported. Code-Snippets ","tags":null,"title":"StreamTags - Replace Stream Tags","url":"/docs/rest-helix/streamtags-replace/"},{"content":"Check subscription status of provided user IDs (one or more) for a given channel Description Gets broadcaster’s subscriptions by user ID (one or more).\nRequired OAuth Scope: channel:read:subscriptions\nMethod Definition @RequestLine(\u0026#34;GET /subscriptions?broadcaster_id={broadcaster_id}\u0026amp;user_id={user_id}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;SubscriptionList\u0026gt; getSubscriptionsByUser( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;broadcaster_id\u0026#34;) Long broadcasterId, @Param(\u0026#34;user_id\u0026#34;) List\u0026lt;Long\u0026gt; userIds ); Required Parameters\nName Type Description token string bearer token broadcaster_id number ID of the broadcaster. Must match the User ID in the Bearer token user_id string Returns streams broadcast by one or more specified user IDs. You can specify up to 100 IDs. Optional Parameters\nNone\nCode-Snippets ","tags":null,"title":"Subscriptions - Check subscription status of provided user IDs (one or more) for a given channel","url":"/docs/rest-helix/subscriptions-byuser/"},{"content":"Get Ingest Server List Description The Twitch ingesting system is the first stop for a broadcast stream. An ingest server receives your stream, and the ingesting system authorizes and registers streams, then prepares them for viewers.\nMethod Definition @RequestLine(\u0026#34;GET /ingests\u0026#34;) HystrixCommand\u0026lt;KrakenIngestList\u0026gt; getIngestServers(); Required Parameters (one of)\nNone\nOptional Parameters\nNone\nCode-Snippets print name of all ingest servers KrakenIngestList resultList = twitchClient.getKraken().getIngestServers().execute(); resultList.getIngests().forEach(ingest -\u0026gt; { System.out.println(ingest.getName()); }); def resultList = twitchClient.kraken.ingestServers.execute(); resultList.ingests.each { ingest -\u0026gt; System.out.println ingest.name } val resultList = twitchClient.kraken.ingestServers.execute(); resultList.ingests.forEach { ingest -\u0026gt; println(ingest.name) } ","tags":null,"title":"Ingests - Get","url":"/docs/rest-kraken/ingests-get/"},{"content":"Proxy Support All components support the usage of a proxy server, it can be set globally like this:\nTwitchClientBuilder\nTwitchClient twitchClient = TwitchClientBuilder.builder() ... .withProxyConfig(ProxyConfig.builder().hostname(\u0026#34;my-proxy-host\u0026#34;).port(8080).build()) ... .build(); def twitchClient = TwitchClientBuilder.builder() ... .withProxyConfig(ProxyConfig.builder().hostname(\u0026#34;my-proxy-host\u0026#34;).port(8080).build()) ... .build() val twitchClient = TwitchClientBuilder.builder() ... .withProxyConfig(ProxyConfig.builder().hostname(\u0026#34;my-proxy-host\u0026#34;).port(8080).build()) ... .build() You can also call .withProxyConfig() on any module builder if you\u0026rsquo;r using some modules standalone.\n","tags":null,"title":"Proxy Support","url":"/docs/getting-started/proxy/"},{"content":"Get Users Description Gets information about one or more specified Twitch users. Users are identified by optional user IDs and/or login name. If neither a user ID nor a login name is specified, the user is looked up by Bearer token.\nMethod Definition @RequestLine(\u0026#34;GET /users?id={id}\u0026amp;login={login}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;UserList\u0026gt; getUsers( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;id\u0026#34;) List\u0026lt;Long\u0026gt; userIds, @Param(\u0026#34;login\u0026#34;) List\u0026lt;String\u0026gt; userNames ); Required Parameters\nNone\nOptional Parameters\nName Type Description authToken string Can be used if requesting information about your own account, to include the email id string User ID. Multiple user IDs can be specified. Limit: 100. login string User login name. Multiple login names can be specified. Limit: 100. Code-Snippets print user list - search by id UserList resultList = twitchClient.getHelix().getUsers(null, Arrays.asList(\u0026#34;149223493\u0026#34;), null).execute(); resultList.getUsers().forEach(user -\u0026gt; { System.out.println(user); }); def resultList = twitchClient.helix.getUsers(null, [\u0026#34;149223493\u0026#34;], null).execute() resultList.users.forEach { user -\u0026gt; System.out.println user } val resultList = twitchClient.helix.getUsers(null, listOf(\u0026#34;149223493\u0026#34;), null).execute() resultList.users.forEach { user -\u0026gt; println(user) } print user list - search by name UserList resultList = twitchClient.getHelix().getUsers(null, null, Arrays.asList(\u0026#34;twitch4j\u0026#34;)).execute(); resultList.getUsers().forEach(user -\u0026gt; { System.out.println(user); }); def resultList = twitchClient.helix.getUsers(null, null, [\u0026#34;twitch4j\u0026#34;]).execute() resultList.users.each { user -\u0026gt; System.out.println user } val resultList = twitchClient.helix.getUsers(null, null, listOf(\u0026#34;twitch4j\u0026#34;)).execute() resultList.users.forEach { user -\u0026gt; println(user) } ","tags":null,"title":"Users - Get","url":"/docs/rest-helix/users-get/"},{"content":"Get Users Follows Description Gets information on follow relationships between two Twitch users. Information returned is sorted in order, most recent follow first. This can return information like “who is lirik following,” “who is following lirik,” or “is user X following user Y.”\nThe response has a JSON payload with a data field containing an array of follow relationship elements and a pagination field containing information required to query for more follow information.\nMethod Definition @RequestLine(\u0026#34;GET /users/follows?from_id={from_id}\u0026amp;to_id={to_id}\u0026amp;after={after}\u0026amp;first={first}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;FollowList\u0026gt; getFollowers( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;from_id\u0026#34;) String fromId, @Param(\u0026#34;to_id\u0026#34;) String toId, @Param(\u0026#34;after\u0026#34;) String after, @Param(\u0026#34;first\u0026#34;) Integer limit ); Required Parameters\nNone\nOptional Parameters\nName Type Description authToken string User Auth Token from_id string User ID. The request returns information about users who are being followed by the from_id user. to_id string User ID. The request returns information about users who are following the to_id user. after string Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. limit integer Maximum number of objects to return. Maximum: 100. Default: 20. Code-Snippets print followers FollowList resultList = twitchClient.getHelix().getFollowers(OAuth2.getAccessToken(), \u0026#34;149223493\u0026#34;, null, null, 100).execute(); resultList.getFollows().forEach(follow -\u0026gt; { System.out.println(follow.getFromName() + \u0026#34; is following \u0026#34; + follow.getToName()); }); def resultList = twitchClient.helix.getFollowers(OAuth2.accessToken, \u0026#34;149223493\u0026#34;, null, null, 100).execute() resultList.follows.each { follow -\u0026gt; System.out.println \u0026#34;${follow.fromName} is following ${follow.toName}\u0026#34; } val resultList = twitchClient.helix.getFollowers(OAuth2.accessToken, \u0026#34;149223493\u0026#34;, null, null, 100).execute() resultList.follows.each { follow -\u0026gt; println(\u0026#34;${follow.fromName} is following ${follow.toName}\u0026#34;) } ","tags":null,"title":"Users - Get Follows","url":"/docs/rest-helix/users-followers/"},{"content":"Update User Description Updates the description of a user specified by a Bearer token.\nMethod Definition @RequestLine(\u0026#34;PUT /users?description={description}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;UserList\u0026gt; updateUser( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;description\u0026#34;) String description ); Required Parameters\nName Type Description authToken string User Auth Token -\u0026gt; user:edit description string The new description Optional Parameters\nNone\nCode-Snippets update the description of a user twitchClient.getHelix().updateUser(accessToken, \u0026#34;Twitch4J IntegrationTest User\u0026#34;).execute(); twitchClient.helix.updateUser(accessToken, \u0026#34;Twitch4J IntegrationTest User\u0026#34;).execute() twitchClient.helix.updateUser(accessToken, \u0026#34;Twitch4J IntegrationTest User\u0026#34;).execute() ","tags":null,"title":"Users - Update","url":"/docs/rest-helix/users-update/"},{"content":"Get User Extensions Description Gets a list of all extensions (both active and inactive) for a specified user, identified by a Bearer token.\nMethod Definition @RequestLine(\u0026#34;GET /users/extensions/list\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;ExtensionList\u0026gt; getUserExtensions( @Param(\u0026#34;token\u0026#34;) String authToken ); Required Parameters\nName Type Description authToken string User Auth Token -\u0026gt; user:read:broadcast Optional Parameters\nNone\nCode-Snippets print all extensions ExtensionList resultList = twitchClient.getHelix().getUserExtensions(accessToken).execute(); resultList.getExtensions().forEach(extension -\u0026gt; { System.out.println(extension); }); def resultList = twitchClient.helix.getUserExtensions(accessToken).execute() resultList.extensions.each { extension -\u0026gt; System.out.println extension } val resultList = twitchClient.helix.getUserExtensions(accessToken).execute() resultList.extensions.forEach { extension -\u0026gt; println(extension) } ","tags":null,"title":"Users - Get Extensions","url":"/docs/rest-helix/users-extensions/"},{"content":"Get User Active Extensions Description Gets information about active extensions installed by a specified user, identified by a user ID or Bearer token.\nMethod Definition @RequestLine(\u0026#34;GET /users/extensions?user_id={user_id}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;ExtensionActiveList\u0026gt; getUserActiveExtensions( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;user_id\u0026#34;) Long userId ); Required Parameters\nNone\nOptional Parameters\nName Type Description authToken string User Auth Token -\u0026gt; user:read:broadcast or user:edit:broadcast user_id string ID of the user whose installed extensions will be returned. Limit: 1. Code-Snippets print active extensions ExtensionActiveList resultList = twitchClient.getHelix().getUserActiveExtensions(testUtils.getCredential().getAccessToken(), twitchUserId).execute(); System.out.println(resultList.getData()); def resultList = twitchClient.helix.getUserActiveExtensions(testUtils.credential.accessToken, twitchUserId).execute() System.out.println resultList.data val resultList = twitchClient.helix.getUserActiveExtensions(testUtils.credential.accessToken, twitchUserId).execute() println(resultList.`data`) ","tags":null,"title":"Users - Get Active Extensions","url":"/docs/rest-helix/users-active-extensions/"},{"content":"Get All Teams Description Gets all active teams.\nMethod Definition @RequestLine(\u0026#34;GET /teams?limit={limit}\u0026amp;offset={offset}\u0026#34;) HystrixCommand\u0026lt;KrakenTeamList\u0026gt; getAllTeams( @Param(\u0026#34;limit\u0026#34;) Long limit, @Param(\u0026#34;offset\u0026#34;) Long offset ); Required Parameters (one of)\nNone\nOptional Parameters\nName Type Description limit number Maximum number of objects to return, sorted by creation date. Default: 25. Maximum: 100. offset number Object offset for pagination of results. Default: 0. Code-Snippets print display name of all teams KrakenTeamList resultList = twitchClient.getKraken().getAllTeams(null, null).execute(); resultList.getTeams().forEach(team -\u0026gt; { System.out.println(team.getDisplayName()); }); def resultList = twitchClient.kraken.getAllTeams(null, null).execute(); resultList.teams.each { team -\u0026gt; System.out.println team.displayName } val resultList = twitchClient.kraken.getAllTeams(null, null).execute(); resultList.teams.forEach { team -\u0026gt; println(team.displayName) } ","tags":null,"title":"Teams - Get All","url":"/docs/rest-kraken/teams-all/"},{"content":"Get Videos Description Gets video information by video ID (one or more), user ID (one only), or game ID (one only).\nThe response has a JSON payload with a data field containing an array of video elements. For lookup by user or game, pagination is available, along with several filters that can be specified as query string parameters.\nMethod Definition @RequestLine(\u0026#34;GET /videos?id={id}\u0026amp;user_id={user_id}\u0026amp;game_id={game_id}\u0026amp;language={language}\u0026amp;period={period}\u0026amp;sort={sort}\u0026amp;type={type}\u0026amp;after={after}\u0026amp;before={before}\u0026amp;first={first}\u0026#34;) @Headers(\u0026#34;Authorization: Bearer {token}\u0026#34;) HystrixCommand\u0026lt;VideoList\u0026gt; getVideos( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;id\u0026#34;) String id, @Param(\u0026#34;user_id\u0026#34;) Long userId, @Param(\u0026#34;game_id\u0026#34;) Long gameId, @Param(\u0026#34;language\u0026#34;) String language, @Param(\u0026#34;period\u0026#34;) String period, @Param(\u0026#34;sort\u0026#34;) String sort, @Param(\u0026#34;type\u0026#34;) String type, @Param(\u0026#34;after\u0026#34;) String after, @Param(\u0026#34;before\u0026#34;) String before, @Param(\u0026#34;first\u0026#34;) Integer limit ); Required Parameters (one of)\nName Type Description id string ID of the video being queried. Limit: 100. If this is specified, you cannot use any of the optional query string parameters below. user_id string ID of the user who owns the video. Limit 1. game_id string ID of the game the video is of. Limit 1. Optional Parameters\nName Type Description authToken string User Auth Token after string Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. before string Cursor for backward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. limit string Maximum number of objects to return. Maximum: 100. Default: 20. language string Language of the video being queried. Limit: 1. period string Period during which the video was created. Valid values: \u0026ldquo;all\u0026rdquo;, \u0026ldquo;day\u0026rdquo;, \u0026ldquo;week\u0026rdquo;, \u0026ldquo;month\u0026rdquo;. Default: \u0026ldquo;all\u0026rdquo;. sort string Sort order of the videos. Valid values: \u0026ldquo;time\u0026rdquo;, \u0026ldquo;trending\u0026rdquo;, \u0026ldquo;views\u0026rdquo;. Default: \u0026ldquo;time\u0026rdquo;. type string Type of video. Valid values: \u0026ldquo;all\u0026rdquo;, \u0026ldquo;upload\u0026rdquo;, \u0026ldquo;archive\u0026rdquo;, \u0026ldquo;highlight\u0026rdquo;. Default: \u0026ldquo;all\u0026rdquo;. Code-Snippets print videos VideoList resultList = twitchClient.getHelix().getVideos(null, null, \u0026#34;488552\u0026#34;, null, null, null, null, null, null, 100).execute(); resultList.getVideos().forEach(video -\u0026gt; { System.out.println(video.getId() + \u0026#34;: \u0026#34; + video.getTitle() + \u0026#34; - by: \u0026#34; + video.getUserName()); }); def resultList = twitchClient.helix.getVideos(null, null, \u0026#34;488552\u0026#34;, null, null, null, null, null, null, 100).execute() resultList.videos.each { video -\u0026gt; System.out.println \u0026#34;${video.id}: ${video.title} - by: ${video.userName}\u0026#34; } val resultList = twitchClient.helix.getVideos(null, null, \u0026#34;488552\u0026#34;, null, null, null, null, null, null, 100).execute() resultList.videos.forEach { video -\u0026gt; println(\u0026#34;${video.id}: ${video.title} - by: ${video.userName}\u0026#34;) } ","tags":null,"title":"Videos - Get","url":"/docs/rest-helix/videos-get/"},{"content":"Get Team by Name Description Gets a specified team object.\nMethod Definition @RequestLine(\u0026#34;GET /teams/{name}\u0026#34;) HystrixCommand\u0026lt;KrakenTeam\u0026gt; getTeamByName( @Param(\u0026#34;name\u0026#34;) String name ); Required Parameters (one of)\nName Type Description name string Name of the team Optional Parameters\nNone\nCode-Snippets get team by name KrakenTeam result = twitchClient.getKraken().getTeamByName(\u0026#34;staff\u0026#34;).execute(); System.out.println(result.getDisplayName()); def result = twitchClient.kraken.getTeamByName(\u0026#34;staff\u0026#34;).execute(); System.out.println result.displayName val result = twitchClient.kraken.getTeamByName(\u0026#34;staff\u0026#34;).execute(); println(result.displayName) ","tags":null,"title":"Teams - Get By Name","url":"/docs/rest-kraken/teams-by-name/"},{"content":"Update the title of a channel Description Updates the channel / stream title\nMethod Definition @RequestLine(\u0026#34;PUT /channels/{channelId}?channel[status]={title}\u0026#34;) HystrixCommand\u0026lt;Object\u0026gt; updateTitle( @Param(\u0026#34;token\u0026#34;) String authToken, @Param(\u0026#34;channelId\u0026#34;) String channelId, @Param(\u0026#34;title\u0026#34;) String title ); Required Parameters (one of)\nName Type Description token string auth token channelId string channel id title string new channel title Optional Parameters\nNone\nCode-Snippets get team by name twitchClient.getKraken().updateTitle(\u0026#34;authToken\u0026#34;, \u0026#34;44322889\u0026#34;, \u0026#34;Hello World!\u0026#34;).execute(); twitchClient.kraken.updateTitle(\u0026#34;authToken\u0026#34;, \u0026#34;44322889\u0026#34;, \u0026#34;Hello World!\u0026#34;).execute(); twitchClient.kraken.updateTitle(\u0026#34;authToken\u0026#34;, \u0026#34;44322889\u0026#34;, \u0026#34;Hello World!\u0026#34;).execute(); ","tags":null,"title":"Channel - Update Title","url":"/docs/rest-kraken/channel-update-title/"},{"content":"Twitch4J - GraphQL Experimental / Unofficial\nThe GraphQL API is as unofficial as it can be. It only works by emulating the twitch website (clientId and accessToken matching the clientId of the twitch site itself).\nTherefore you need to use the client id of the twitch site and a auth token of the twitch site - a self generated token will not work.\nAs Module: Twitch4J To use GraphQL you need to enable the GraphQL Module when building the Twitch4J Instance, as shown below:\nTwitchClient twitchClient = TwitchClientBuilder.builder() ... .withEnableGraphQL(true) ... .build(); def twitchClient = TwitchClientBuilder.builder() ... .withEnableGraphQL(true) ... .build() val twitchClient = TwitchClientBuilder.builder() ... .withEnableGraphQL(true) ... .build() Standalone Initialize the GraphQL as Standalone Module:\nTwitchGraphQL client = TwitchGraphQLBuilder.builder().build(); def client = TwitchGraphQLBuilder.builder().build() val client = TwitchGraphQLBuilder.builder().build() API Methods User:\nUser -\u0026gt; Follow User User -\u0026gt; Unfollow User ","tags":null,"title":"GraphQL","url":"/docs/graphql/"},{"content":"Events Twitch4J uses Events4J to dispatch events and handle them, you can also build your own event handler to handle them however you like. You can use those events to build chat bots or similar tools.\nPublish Event Publish a event that should be processed somewhere:\nThe event object needs to implement the IEvent interface. The event will be passed to all registered handlers. eventManager.publish(object); eventManager.publish(object) eventManager.publish(`object`) Handle / Process Events Twitch4J uses the SimpleHandler by default which works on all platforms.\nHandlers:\nSimpleHandler ReactorHandler SpringHandler You can register listeners directly on the eventManager, the call is forwarded and registered on the current defaultEventHandler set in the eventManager instance.\nSwitch the default event handler If you want all your events to be processed by a specific eventHandler, then check out the following pages on all available eventHandlers:\nSimpleEventHandler (Default) ReactorEventHandler Register your event listeners in a generic way Only the consumers registered with eventManager.onEvent will use the defaultEventHandler.\n// register handler IDisposable handlerReg = twitchClient.getEventManager().onEvent(ChannelMessageEvent.class, event -\u0026gt; { System.out.println \u0026#34;[\u0026#34; + event.getChannel().getName() + \u0026#34;][\u0026#34;+event.getPermissions().toString()+\u0026#34;] \u0026#34; + event.getUser().getName() + \u0026#34;: \u0026#34; + event.getMessage()); }); // cancel handler (don\u0026#39;t call the method for new events of the required type anymore) handlerReg.dispose(); // register handler def handlerReg = twitchClient.eventManager.onEvent(ChannelMessageEvent) { event -\u0026gt; System.out.println \u0026#34;[${event.channel.name}][${event.permissions}] ${event.user.name}: ${event.message}\u0026#34; } // cancel handler (don\u0026#39;t call the method for new events of the required type anymore) handlerReg.dispose() // register handler val handlerReg = twitchClient.eventManager.onEvent(ChannelMessageEvent::class.java) { event -\u0026gt; println(\u0026#34;[${event.channel.name}][${event.permissions}] ${event.user.name}: ${event.message}\u0026#34;) } // cancel handler (don\u0026#39;t call the method for new events of the required type anymore) handlerReg.dispose() This is the recommended method to register listeners, as you can switch between the different EventHandlers by chaning a single line of code.\nSimple Handler The default event handler can register handlers with annotations or provide lambdas as consumers.\nLambda / Consumer Example // register handler IDisposable handlerReg = twitchClient.getEventManager().getEventHandler(SimpleEventHandler.class).onEvent(ChannelMessageEvent.class, event -\u0026gt; { System.out.println(\u0026#34;[\u0026#34; + event.getChannel().getName() + \u0026#34;][\u0026#34;+event.getPermissions().toString()+\u0026#34;] \u0026#34; + event.getUser().getName() + \u0026#34;: \u0026#34; + event.getMessage()); }); // cancel handler (don\u0026#39;t call the method for new events of the required type anymore) handlerReg.dispose(); // register handler def handlerReg = twitchClient.eventManager.getEventHandler(SimpleEventHandler).onEvent ChannelMessageEvent, { event -\u0026gt; System.out.println \u0026#34;[${event.channel.name}][${event.permissions}] ${event.user.name}: ${event.message} \u0026#34; } // cancel handler (don\u0026#39;t call the method for new events of the required type anymore) handlerReg.dispose() // register handler val handlerReg = twitchClient.eventManager.getEventHandler(SimpleEventHandler::class.java).onEvent(ChannelMessageEvent::class.java) { event -\u0026gt; println(\u0026#34;[${event.channel.name}][${event.permissions}] ${event.user.name}: ${event.message}\u0026#34;) } // cancel handler (don\u0026#39;t call the method for new events of the required type anymore) handlerReg.dispose() Annotation Example public class MyEventHandler { // the type of the 1st argument is relevant, you can pick any method name you want @EventSubscriber public void printChannelMessage(ChannelMessageEvent event) { System.out.println(\u0026#34;[\u0026#34; + event.getChannel().getName() + \u0026#34;][\u0026#34;+event.getPermissions().toString()+\u0026#34;] \u0026#34; + event.getUser().getName() + \u0026#34;: \u0026#34; + event.getMessage()); } } // register your handler class MyEventHandler myEventHandler = new MyEventHandler(); eventManager.getEventHandler(SimpleEventHandler.class).registerListener(myEventHandler); class MyEventHandler { // the type of the 1st argument is relevant, you can pick any method name you want @EventSubscriber def printChannelMessage(ChannelMessageEvent event) { System.out.println \u0026#34;[${event.channel.name}][${event.permissions}] ${event.user.name}: ${event.message}\u0026#34; } } // register your handler class def myEventHandler = new MyEventHandler(); eventManager.getEventHandler(SimpleEventHandler).registerListener(myEventHandler); class MyEventHandler { // the type of the 1st argument is relevant, you can pick any method name you want @EventSubscriber fun printChannelMessage(ChannelMessageEvent event) { println(\u0026#34;[${event.channel.name}][${event.permissions}] ${event.user.name}: ${event.message}\u0026#34;) } } // register your handler class val myEventHandler = MyEventHandler(); eventManager.getEventHandler(SimpleEventHandler::class.java).registerListener(myEventHandler); Cheat Sheet Key Value Handler Execution sync Android compatible Reactor Handler If desired you can also use the ReactorHandler to use reactive streams to process events (keep in mind that this will not work with android). To enable reactor add the ReactorHandler dependency, it will be discovered and registered automatically.\ncompile group: \u0026#39;com.github.philippheuer.events4j\u0026#39;, name: \u0026#39;events4j-handler-reactor\u0026#39;, version: \u0026#39;0.9.8\u0026#39; // Since Gradle 5+ implementation group: \u0026#39;com.github.philippheuer.events4j\u0026#39;, name: \u0026#39;events4j-handler-reactor\u0026#39;, version: \u0026#39;0.9.8\u0026#39; implementation(group = \u0026#34;com.github.philippheuer.events4j\u0026#34;, name = \u0026#34;events4j-handler-reactor\u0026#34;, version = \u0026#34;0.9.8\u0026#34;) \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.philippheuer.events4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;events4j-handler-reactor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; // register handler Disposable handlerReg = twitchClient.getEventManager().getEventHandler(ReactorEventHandler.class).onEvent(ChannelMessageEvent.class, event -\u0026gt; { System.out.println(\u0026#34;[\u0026#34; + event.getChannel().getName() + \u0026#34;][\u0026#34;+event.getPermissions().toString()+\u0026#34;] \u0026#34; + event.getUser().getName() + \u0026#34;: \u0026#34; + event.getMessage()); }); // cancel handler (don\u0026#39;t call the method for new events of the required type anymore) handlerReg.dispose(); // register handler def handlerReg = twitchClient.eventManager.getEventHandler(ReactorEventHandler).onEvent ChannelMessageEvent, { event -\u0026gt; System.out.println \u0026#34;[${event.channel.name}]${event.permissions}] ${event.user.name}: ${event.message}\u0026#34; } // cancel handler (don\u0026#39;t call the method for new events of the required type anymore) handlerReg.dispose(); // register handler val handlerReg = twitchClient.eventManager.getEventHandler(ReactorEventHandler::class.java).onEvent(ChannelMessageEvent::class.java) { event -\u0026gt; println(\u0026#34;[${event.channel.name}]${event.permissions}] ${event.user.name}: ${event.message}\u0026#34;) } // cancel handler (don\u0026#39;t call the method for new events of the required type anymore) handlerReg.dispose(); Cheat Sheet Key Value Handler Execution async Android incompatible Spring Handler If desired you can also use the SpringHandler to handle all events as Spring Application Events. To enable reactor add the SpringHandler dependency, it will be discovered and registered automatically.\ncompile group: \u0026#39;com.github.philippheuer.events4j\u0026#39;, name: \u0026#39;events4j-handler-spring\u0026#39;, version: \u0026#39;0.9.8\u0026#39; // Since Gradle 5+ implementation group: \u0026#39;com.github.philippheuer.events4j\u0026#39;, name: \u0026#39;events4j-handler-spring\u0026#39;, version: \u0026#39;0.9.8\u0026#39; implementation(group = \u0026#34;com.github.philippheuer.events4j\u0026#34;, name = \u0026#34;events4j-handler-spring\u0026#34;, version = \u0026#34;0.9.8\u0026#34;) \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.philippheuer.events4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;events4j-handler-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Event Catalog This will become a list of all available events.\nChannel:\nChannelMessageEvent ChannelChangeGameEvent ChannelChangeTitleEvent ChannelGoLiveEvent ChannelGoOfflineEvent User:\nPrivateMessageEvent Generic:\nIRCMessageEvent And many more, this is a very incomplete list\n","tags":null,"title":"Events","url":"/docs/events/"},{"content":"RAW IRC Message Event Description The irc message received before it gets parsed and the real event gets dispatched.\nDependencies Requires the TwitchChat Module to be enabled and active for the source channel. See TwitchChat.\nExamples Printing the RAW Message eventManager.onEvent(IRCMessageEvent.class, event -\u0026gt; { System.out.println(event.getRawMessage()); }); eventManager.onEvent(IRCMessageEvent) { event -\u0026gt; System.out.println event.rawMessage } eventManager.onEvent(IRCMessageEvent::class.java) { event -\u0026gt; println(event.rawMessage); } ","tags":null,"title":"IRC Message","url":"/docs/events/irc-message-event/"},{"content":"EventHandler - Simple Description The SimpleEventHandler will process all events synchronous in the current thread.\nDependencies api group: \u0026#39;com.github.philippheuer.events4j\u0026#39;, name: \u0026#39;events4j-handler-simple\u0026#39;, version: \u0026#39;0.9.2\u0026#39; api(group = \u0026#34;com.github.philippheuer.events4j\u0026#34;, name = \u0026#34;events4j-handler-simple\u0026#34;, version = \u0026#34;0.9.2\u0026#34;) \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.philippheuer.events4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;events4j-handler-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Set as default in Twitch4J and for eventManager.onEvent TwitchClient twitchClient = TwitchClientBuilder.builder() .withDefaultEventHandler(SimpleEventHandler.class) .build(); ","tags":null,"title":"EventHandler - Simple","url":"/docs/events/eventhandler-simple/"},{"content":"EventHandler - Reactor Description The ReactorEventHandler will process all events asynchronous in a threadpool with at least 4 threads.\nCheck out the following class if you want to customize the parameters used when building a ReactorEventHandler instance:\nReactorEventHandler.java Dependencies api group: \u0026#39;com.github.philippheuer.events4j\u0026#39;, name: \u0026#39;events4j-handler-reactor\u0026#39;, version: \u0026#39;0.9.2\u0026#39; api(group = \u0026#34;com.github.philippheuer.events4j\u0026#34;, name = \u0026#34;events4j-handler-reactor\u0026#34;, version = \u0026#34;0.9.2\u0026#34;) \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.philippheuer.events4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;events4j-handler-reactor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Set as default in Twitch4J and for eventManager.onEvent TwitchClient twitchClient = TwitchClientBuilder.builder() .withDefaultEventHandler(ReactorEventHandler.class) .build(); def twitchClient = TwitchClientBuilder.builder() .withDefaultEventHandler(ReactorEventHandler) .build(); val twitchClient = TwitchClientBuilder.builder() .withDefaultEventHandler(ReactorEventHandler::class.java) .build(); ","tags":null,"title":"EventHandler - Reactor","url":"/docs/events/eventhandler-reactor/"},{"content":"ChannelChangeGameEvent Description The ChannelChangeGameEvent is triggered when a monitored channel changes the game.\nDependencies Requires the specific channels to be registered with the TwitchClient Helper. See TwitchClientHelper\nExamples Example 1 eventManager.onEvent(ChannelChangeGameEvent.class, event -\u0026gt; { System.out.println(\u0026#34;[\u0026#34; + event.getChannel().getName() + \u0026#34;] is now playing \u0026#34; + event.getGameId() + \u0026#34;!\u0026#34;); }); eventManager.onEvent(ChannelChangeGameEvent) { event -\u0026gt; System.out.println \u0026#34;[${event.channel.name}] is now playing ${event.gameId}!\u0026#34; } eventManager.onEvent(ChannelChangeGameEvent::class.java) { event -\u0026gt; println(\u0026#34;[${event.channel.name}] is now playing ${event.gameId}!\u0026#34;) } ","tags":null,"title":"Channel - Change Game Event","url":"/docs/events/channel-change-game-event/"},{"content":"ChannelChangeTitleEvent Description The ChannelChangeTitleEvent is triggered when a monitored channel changes it\u0026rsquo;s title.\nDependencies Requires the specific channels to be registered with the TwitchClient Helper. See TwitchClientHelper\nExamples Example 1 eventManager.onEvent(ChannelChangeTitleEvent.class, event -\u0026gt; { System.out.println(\u0026#34;[\u0026#34; + event.getChannel().getName() + \u0026#34;] changed his stream title to \u0026#34; + event.getTitle() + \u0026#34;!\u0026#34;); }); eventManager.onEvent(ChannelChangeTitleEvent) { event -\u0026gt; System.out.println \u0026#34;[${event.channel.name}] changed his stream title to ${event.title}!\u0026#34; } eventManager.onEvent(ChannelChangeTitleEvent::class.java) { event -\u0026gt; println(\u0026#34;[${event.channel.name}] changed his stream title to ${event.title}!\u0026#34;) } ","tags":null,"title":"Channel - Change Title Event","url":"/docs/events/channel-change-title-event/"},{"content":"ChannelGoLiveEvent Description The ChannelGoLiveEvent is triggered when a monitored channel goes live.\nDependencies Requires the specific channels to be registered with the TwitchClient Helper. See TwitchClientHelper\nExamples Example 1 eventManager.onEvent(ChannelGoLiveEvent.class, event -\u0026gt; { System.out.println(\u0026#34;[\u0026#34; + event.getChannel().getName() + \u0026#34;] went live with title \u0026#34; + event.getTitle() + \u0026#34; on game \u0026#34; + event.getGameId() + \u0026#34;!\u0026#34;); }); eventManager.onEvent(ChannelGoLiveEvent) { event -\u0026gt; System.out.println \u0026#34;[${event.channel.name}] went live with title ${event.title} on game ${event.gameId}!\u0026#34; } eventManager.onEvent(ChannelGoLiveEvent::class.java) { event -\u0026gt; println(\u0026#34;[${event.channel.name}] went live with title ${event.title} on game ${event.gameId}!\u0026#34;); } ","tags":null,"title":"Channel - Go Live Event","url":"/docs/events/channel-go-live-event/"},{"content":"ChannelGoOfflineEvent Description The ChannelGoOfflineEvent is triggered when a monitored channel goes offline.\nDependencies Requires the specific channels to be registered with the TwitchClient Helper. See TwitchClientHelper\nExamples Example 1 eventManager.onEvent(ChannelGoOfflineEvent.class, event -\u0026gt; { System.out.println(\u0026#34;[\u0026#34; + event.getChannel().getName() + \u0026#34;] just went offline!\u0026#34;); }); eventManager.onEvent(ChannelGoOfflineEvent) { event -\u0026gt; System.out.println \u0026#34;[${event.channel.name}] just went offline!\u0026#34; } eventManager.onEvent(ChannelGoOfflineEvent::class.java) { event -\u0026gt; println(\u0026#34;[${event.channel.name}] just went offline!\u0026#34;) } ","tags":null,"title":"Channel - Go Offline Event","url":"/docs/events/channel-go-offline-event/"},{"content":"ChannelMessageEvent Description The ChannelMessageEvent is triggered for every normal message in irc.\nDependencies Requires the TwitchChat Module to be enabled and active for the source channel. See TwitchChat.\nExamples Write Chat to Console eventManager.onEvent(ChannelMessageEvent.class, event -\u0026gt; { System.out.println(\u0026#34;[\u0026#34; + event.getChannel().getName() + \u0026#34;] \u0026#34; + event.getUser().getName() + \u0026#34;: \u0026#34; + event.getMessage()); }); eventManager.onEvent(ChannelMessageEvent) { event -\u0026gt; System.out.println \u0026#34;[${event.channel.name}] ${event.user.name}: ${event.message}\u0026#34; } eventManager.onEvent(ChannelMessageEvent::class.java) { event -\u0026gt; println(\u0026#34;[${event.channel.name}] ${event.user.name}: ${event.message}\u0026#34;) } ","tags":null,"title":"Channel - MessageEvent","url":"/docs/events/channel-message-event/"},{"content":"PrivateMessageEvent Description The PrivateMessageEvent is triggered for private messages / whispers and can be triggered from PubSub or Chat.\nDependencies Requires the TwitchChat Module to be enabled and active for the source channel. See TwitchChat. Otherwise you will need to enable PubSub and subscribe to the whispers topic the receive PrivateMessageEvents.\nExamples Listen for PrivateMessageEvent eventManager.onEvent(PrivateMessageEvent.class, event -\u0026gt; { System.out.println(\u0026#34;[Whisper] \u0026#34; + event.getUser().getName() + \u0026#34;: \u0026#34; + event.getMessage()); }); eventManager.onEvent(PrivateMessageEvent) { event -\u0026gt; System.out.println \u0026#34;[Whisper] ${event.user.name}: ${event.message}\u0026#34; } eventManager.onEvent(PrivateMessageEvent::class.java) { event -\u0026gt; println(\u0026#34;[Whisper] ${event.user.name}: ${event.message}\u0026#34;) } ","tags":null,"title":"User - Private Message / Whisper","url":"/docs/events/private-message-event/"},{"content":"Contribution This section contains information about the relase process / documentation / and other information useful for project maintenance and contribution.\nIDE Setup Pull Requests Release Process Web Documentation Code Documentation ","tags":null,"title":"Contribution","url":"/docs/contribution/"},{"content":"Acknowledgements We would like to thank the following companies and organisations for their support in our open-source project development.\nThank you!\nJetbrains JetBrains provides us with a free all products license. You can checkout their products here.\nYourKit Twitch4J uses the YourKit Java Profiler for Performance Tuning.\nYourKit supports open source projects with innovative and intelligent tools for monitoring and profiling Java and .NET applications. YourKit is the creator of YourKit Java Profiler, YourKit .NET Profiler, and YourKit YouMonitor.\n","tags":null,"title":"Acknowledgements","url":"/docs/acknowledgements/"},{"content":"Join Channel Description Joins a channel on irc, and as such will receive any kind of events for that channel (Messages, Subscriptions, Bits, \u0026hellip;)\nA join is stored, as such you will automatically rejoin channels in case there was a disconnect or similar.\nExample twitchClient.getChat().joinChannel(\u0026#34;PlayOverwatch\u0026#34;); twitchClient.chat.joinChannel(\u0026#34;PlayOverwatch\u0026#34;) twitchClient.chat.joinChannel(\u0026#34;PlayOverwatch\u0026#34;) ","tags":null,"title":"Join Channel","url":"/docs/chat/join-channel/"}]